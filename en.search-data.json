{"/blogcuatruc.github.io/blog/bai-1-tong-quan-ve-java/":{"data":{"":"","-ví-dụ-đầu-tiên-với-java#💡 Ví dụ đầu tiên với Java":"Hãy cùng viết chương trình kinh điển “Hello, World!” trong Java:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\"Xin chào, Java!\"); } }","câu-hỏi-gợi-mở#Câu hỏi gợi mở":"Bạn đã từng viết chương trình đầu tiên bằng Java chưa? Nếu chưa, hãy thử ngay ví dụ “Hello World” phía trên nhé!","giải-thích-cú-pháp-cơ-bản#Giải thích cú pháp cơ bản":"public class HelloWorld Khai báo một lớp công khai tên là HelloWorld.\npublic static void main Là phương thức chính — điểm bắt đầu khi chương trình chạy.\nSystem.out.println(...) In ra dòng chữ lên màn hình.","giới-thiệu#Giới thiệu":"Java là một trong những ngôn ngữ lập trình lâu đời và phổ biến nhất trong lĩnh vực phát triển phần mềm.\nRa đời năm 1995 bởi James Gosling tại Sun Microsystems, Java được thiết kế với phương châm “Write once, run anywhere” (Viết một lần, chạy mọi nơi).\nĐiều này có nghĩa là chương trình viết bằng Java có thể chạy trên bất kỳ nền tảng nào có cài đặt Java Virtual Machine (JVM).","gợi-ý-hình-minh-họa#Gợi ý hình minh họa":"Đặt ảnh vào thư mục static/images/java-intro-banner.jpg (VD: ảnh Java logo hoặc laptop với code Java)","kiến-trúc-của-java#Kiến trúc của Java":"Khi bạn chạy một chương trình Java, quá trình diễn ra như sau:\nMã nguồn (.java) được biên dịch thành bytecode (.class). JVM (Java Virtual Machine) đọc bytecode và thực thi trên máy thật. 📊 Sơ đồ tổng quát:\nflowchart TD A[\"Mã nguồn Java (.java)\"] --\u003e B[\"Trình biên dịch javac\"] B --\u003e C[\"Bytecode (.class)\"] C --\u003e D[\"JVM\"] D --\u003e E[\"Máy thật (Windows/Linux/Mac)\"] style A fill:#e1f5fe style B fill:#fff3e0 style C fill:#f3e5f5 style D fill:#e8f5e8 style E fill:#fff8e1","kết-luận#Kết luận":"Java vẫn giữ vị thế quan trọng trong thế giới lập trình nhờ tính ổn định, bảo mật và cộng đồng lớn mạnh.\nTrong các bài viết tiếp theo, chúng ta sẽ cùng nhau đi sâu hơn vào:\nCấu trúc chương trình Java Lập trình hướng đối tượng (OOP) Và các kỹ thuật Java trong lập trình mạng","đặc-điểm-nổi-bật-của-java#Đặc điểm nổi bật của Java":"Đặc điểm Mô tả Đa nền tảng Chạy được trên nhiều hệ điều hành (Windows, macOS, Linux, Android, v.v.) Hướng đối tượng Mọi thứ trong Java đều là đối tượng — giúp quản lý và tái sử dụng mã hiệu quả Bảo mật cao Có lớp kiểm soát truy cập mạnh và cơ chế sandbox để ngăn mã độc Thư viện phong phú Cung cấp hàng ngàn thư viện hỗ trợ mạng, giao diện, cơ sở dữ liệu, web, v.v. Hiệu suất ổn định JVM tối ưu hiệu năng qua JIT Compiler","ứng-dụng-thực-tế-của-java#Ứng dụng thực tế của Java":"Java được sử dụng ở rất nhiều lĩnh vực:\nỨng dụng doanh nghiệp (Enterprise Java) Ứng dụng Android (Java là nền tảng cho Android SDK) Ứng dụng web (Spring Boot, JSP, Servlets) Điện toán đám mây (AWS, Azure) Hệ thống nhúng, phần mềm máy chủ"},"title":"Tổng quan về ngôn ngữ lập trình Java"},"/blogcuatruc.github.io/blog/bai-10-xu-ly-bat-dong-bo/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Khi làm việc với Fetch API, ta thường thấy cú pháp như sau:\nfetch(url) .then(response =\u003e response.json()) .then(data =\u003e console.log(data)) .catch(error =\u003e console.error(error));\rCách viết này hoạt động tốt, nhưng khi chuỗi thao tác phức tạp (nhiều .then() lồng nhau) thì code dễ rối. Giải pháp: async/await — cú pháp mới của ES2017 giúp xử lý Promise gọn gàng, dễ đọc như code đồng bộ.","2-cách-hoạt-động-của-asyncawait#2. Cách hoạt động của async/await":"async khai báo một hàm bất đồng bộ, hàm này luôn trả về Promise. await được dùng bên trong hàm async, giúp “tạm dừng” hàm cho đến khi Promise hoàn thành.","3-gửi-dữ-liệu-bằng-fetch-post-request#3. Gửi dữ liệu bằng Fetch (POST request)":"Trong thực tế, bạn không chỉ “lấy dữ liệu” mà còn “gửi dữ liệu” từ form hoặc ứng dụng đến server.\nVí dụ sau minh họa cách gửi dữ liệu bài viết mới bằng fetch() kết hợp async/await.\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ePOST với Fetch API\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: #f7f9fc; padding: 20px; } form { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); max-width: 400px; margin-bottom: 30px; } input, textarea { width: 100%; margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; } button { background: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 6px; cursor: pointer; } button:hover { background: #2980b9; } .result { background: #eaf6ff; padding: 15px; border-radius: 8px; max-width: 400px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eTạo bài viết mới\u003c/h1\u003e \u003cform id=\"postForm\"\u003e \u003cinput type=\"text\" id=\"title\" placeholder=\"Tiêu đề\" required /\u003e \u003ctextarea id=\"body\" placeholder=\"Nội dung\" rows=\"4\" required\u003e\u003c/textarea\u003e \u003cbutton type=\"submit\"\u003eGửi bài viết\u003c/button\u003e \u003c/form\u003e \u003cdiv id=\"result\" class=\"result\"\u003e\u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","4-phân-tích-hoạt-động#4. Phân tích hoạt động":"Bước Mô tả 1 Người dùng nhập tiêu đề và nội dung vào form 2 Khi bấm “Gửi bài viết”, JS ngăn reload trang (preventDefault()) 3 fetch() gửi dữ liệu dạng JSON đến API 4 Server phản hồi lại dữ liệu đã gửi (có ID mới) 5 Kết quả hiển thị ngay trên giao diện","5-ưu-điểm-của-asyncawait#5. Ưu điểm của async/await":"Dễ đọc – không cần .then() lồng nhau Xử lý lỗi tự nhiên với try…catch Phù hợp cho các tác vụ bất đồng bộ phức tạp (gọi API nối tiếp, upload file, chờ dữ liệu,…)","6-tổng-kết#6. Tổng kết":"Khái niệm Ý nghĩa async Định nghĩa hàm bất đồng bộ await Tạm dừng cho đến khi Promise hoàn tất try…catch Bắt lỗi dễ dàng hơn trong code bất đồng bộ async/await giúp Fetch API trở nên dễ dùng và trực quan hơn, là công cụ không thể thiếu trong các ứng dụng web hiện đại.","bài-tập-luyện-tập#Bài tập luyện tập":"Sửa ví dụ trên để hiển thị thông báo “Đang gửi dữ liệu…” khi chờ phản hồi từ server. Thêm nút “Làm mới danh sách bài viết” để gọi lại API và hiển thị bài mới nhất. Kết hợp GET và POST để tạo trang blog mini với JavaScript.","javascript-file-scriptjs#JavaScript (file script.js)":"const form = document.getElementById(\"postForm\"); const result = document.getElementById(\"result\"); form.addEventListener(\"submit\", async (e) =\u003e { e.preventDefault(); const newPost = { title: document.getElementById(\"title\").value, body: document.getElementById(\"body\").value, userId: 1 }; try { const response = await fetch(\"https://jsonplaceholder.typicode.com/posts\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(newPost) }); const data = await response.json(); result.innerHTML = ` Bài viết đã được gửi! ID: ${data.id}\nTiêu đề: ${data.title}\nNội dung: ${data.body}\n`; } catch (error) { result.innerHTML = `Lỗi gửi dữ liệu: ${error}\n`; } });","kết-quả-in-ra-theo-thứ-tự-dễ-đọc#Kết quả in ra theo thứ tự dễ đọc:":"Bắt đầu...\r{ id: 1, title: \"...\", body: \"...\" }\rKết thúc!","ví-dụ#Ví dụ:":"async function demo() { console.log(\"Bắt đầu...\"); const data = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\"); const post = await data.json(); console.log(post); console.log(\"Kết thúc!\"); } demo();"},"title":"Xử lý bất đồng bộ với async/await – Viết code Fetch API gọn gàng hơn"},"/blogcuatruc.github.io/blog/bai-11-luu-du-lieu-tren-local-storage/":{"data":{"":"","-cú-pháp-cơ-bản#🧠 Cú pháp cơ bản":"// Lưu dữ liệu localStorage.setItem(\"username\", \"Ngọc Trúc\"); // Lấy dữ liệu const user = localStorage.getItem(\"username\"); console.log(user); // \"Ngọc Trúc\" // Xóa một mục localStorage.removeItem(\"username\"); // Xóa toàn bộ localStorage.clear();\rLưu ý: Dữ liệu được lưu ở dạng chuỗi (string). Nếu bạn muốn lưu đối tượng hoặc mảng, hãy chuyển sang JSON.\nconst settings = { theme: \"dark\", fontSize: 18 }; localStorage.setItem(\"settings\", JSON.stringify(settings)); const savedSettings = JSON.parse(localStorage.getItem(\"settings\")); console.log(savedSettings.theme); // dark","1-giới-thiệu#1. Giới thiệu":"Khi bạn truy cập một trang web, liệu bạn có bao giờ tự hỏi vì sao trình duyệt có thể “nhớ” được tên đăng nhập, giỏ hàng, hoặc chế độ tối/sáng?\nCâu trả lời nằm ở Web Storage API — trong đó có Local Storage và Session Storage, cho phép JavaScript lưu dữ liệu tạm thời hoặc lâu dài ngay trong trình duyệt mà không cần server.","2-sự-khác-nhau-giữa-local-storage-và-session-storage#2. Sự khác nhau giữa Local Storage và Session Storage":"Tính năng Local Storage Session Storage Thời gian lưu Vĩnh viễn (cho đến khi bị xóa) Chỉ tồn tại trong phiên làm việc (tab) Kích thước tối đa Khoảng 5MB Khoảng 5MB Truy cập Dữ liệu vẫn còn sau khi đóng trình duyệt Mất khi đóng tab hoặc cửa sổ Phạm vi Mọi tab cùng domain Riêng từng tab","3-cách-sử-dụng-local-storage#3. Cách sử dụng Local Storage":"","4-cách-sử-dụng-session-storage#4. Cách sử dụng Session Storage":"Cú pháp tương tự Local Storage, chỉ khác là dữ liệu mất khi đóng tab:\nsessionStorage.setItem(\"cart\", JSON.stringify([\"Laptop\", \"Chuột\"])); const cart = JSON.parse(sessionStorage.getItem(\"cart\")); console.log(cart); // [\"Laptop\", \"Chuột\"]","5-ví-dụ-thực-tế-ghi-nhớ-chế-độ-giao-diện-darklight-mode#5. Ví dụ thực tế: Ghi nhớ chế độ giao diện (Dark/Light Mode)":"\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003eDark Mode Demo\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: var(--bg); color: var(--text); transition: all 0.3s ease; text-align: center; padding: 50px; } button { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; } button:hover { background: #2980b9; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e🌗 Chế độ giao diện\u003c/h1\u003e \u003cbutton id=\"toggleBtn\"\u003eChuyển chế độ\u003c/button\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","6-tổng-kết#6. Tổng kết":"API Mục đích Thời gian lưu Local Storage Lưu thông tin lâu dài (cài đặt, token, theme) Vĩnh viễn Session Storage Lưu thông tin tạm thời (dữ liệu form, trạng thái tab) Khi tab còn mở","7-bài-tập-thực-hành#7. Bài tập thực hành":"Tạo ứng dụng “Ghi chú cá nhân” lưu ghi chú bằng Local Storage. Tạo form đăng nhập demo, lưu trạng thái đăng nhập tạm thời bằng Session Storage. Kết hợp Fetch API + Local Storage để cache dữ liệu API, giúp load nhanh hơn khi người dùng mở lại trang.","javascript-scriptjs#JavaScript (script.js)":"const body = document.body; const btn = document.getElementById(\"toggleBtn\"); function applyTheme(theme) { if (theme === \"dark\") { document.documentElement.style.setProperty(\"--bg\", \"#121212\"); document.documentElement.style.setProperty(\"--text\", \"#ffffff\"); } else { document.documentElement.style.setProperty(\"--bg\", \"#ffffff\"); document.documentElement.style.setProperty(\"--text\", \"#000000\"); } } // Lấy chế độ đã lưu let currentTheme = localStorage.getItem(\"theme\") || \"light\"; applyTheme(currentTheme); btn.addEventListener(\"click\", () =\u003e { currentTheme = currentTheme === \"light\" ? \"dark\" : \"light\"; localStorage.setItem(\"theme\", currentTheme); applyTheme(currentTheme); });\rKhi bạn chọn chế độ tối, trình duyệt sẽ ghi nhớ lựa chọn này và tự động áp dụng lại ngay cả khi bạn đóng và mở lại trang."},"title":"Lưu dữ liệu trên trình duyệt với Local Storage và Session Storage"},"/blogcuatruc.github.io/blog/bai-12-xu-ly-loi-va-go-loi/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Không lập trình viên nào tránh khỏi lỗi. Dù bạn là người mới học hay đã có kinh nghiệm, việc biết gỡ lỗi (debugging) và xử lý lỗi (error handling) là kỹ năng bắt buộc để viết phần mềm ổn định và đáng tin cậy.\nTrong JavaScript, ta có rất nhiều cách để phát hiện, theo dõi và khắc phục lỗi, bao gồm:\nSử dụng Console API để kiểm tra biến, log dữ liệu. Dùng try…catch…finally để xử lý ngoại lệ. Hiểu các loại lỗi phổ biến và cách tránh chúng. Dùng DevTools của trình duyệt để debug từng bước.","2-dò-lỗi-bằng-console#2. Dò lỗi bằng Console":"console là công cụ thân quen của mọi lập trình viên web.","3-các-loại-lỗi-phổ-biến-trong-javascript#3. Các loại lỗi phổ biến trong JavaScript":"Loại lỗi Nguyên nhân Ví dụ SyntaxError Sai cú pháp if (x \u003e 5 { ReferenceError Biến chưa được định nghĩa console.log(userName); // userName chưa khai báo TypeError Gọi sai kiểu dữ liệu \"hello\".push(\"!\") RangeError Giá trị nằm ngoài phạm vi (12345).toFixed(200) NetworkError Lỗi khi gọi API fetch(\"https://wrong-url.com\")","4-xử-lý-lỗi-bằng-trycatchfinally#4. Xử lý lỗi bằng try\u0026hellip;catch\u0026hellip;finally":"","5-tự-tạo-lỗi-với-throw#5. Tự tạo lỗi với throw":"Bạn có thể chủ động ném lỗi khi dữ liệu không hợp lệ:\nfunction divide(a, b) { if (b === 0) { throw new Error(\"Không thể chia cho 0!\"); } return a / b; } try { console.log(divide(10, 0)); } catch (e) { console.error(\"Lỗi:\", e.message); }","6-debug-từng-bước-bằng-devtools#6. Debug từng bước bằng DevTools":"Mở DevTools (F12) → tab Sources → đặt breakpoint ở dòng bạn muốn dừng. Sau đó: Nhấn F10 để chạy từng dòng. Nhấn F8 để tiếp tục chương trình. Quan sát giá trị biến trong Scope. Cách này cực hữu ích khi chương trình dài hoặc lỗi không rõ nguyên nhân.","7-ví-dụ-thực-tế-debug-lỗi-khi-gọi-api#7. Ví dụ thực tế: Debug lỗi khi gọi API":"async function fetchPosts() { try { console.log(\"Đang gọi API...\"); const res = await fetch(\"https://jsonplaceholder.typicode.com/postsss\"); // lỗi URL if (!res.ok) throw new Error(\"Lỗi kết nối API!\"); const data = await res.json(); console.table(data.slice(0, 3)); } catch (err) { console.error(\"Không thể tải dữ liệu:\", err.message); } finally { console.log(\"Kết thúc quá trình fetch.\"); } } fetchPosts();","8-thực-hành-nhanh#8. Thực hành nhanh":"Viết chương trình nhập số chia (a, b), xử lý lỗi chia cho 0. Thử ném lỗi khi JSON không hợp lệ (JSON.parse('{name:\"An\"}')). Gọi API sai URL và xử lý lỗi mạng. Đặt breakpoint và debug từng dòng trong DevTools.","9-tổng-kết#9. Tổng kết":"Kỹ thuật Mục đích console.log / warn / error In thông tin ra console để theo dõi try…catch…finally Xử lý lỗi runtime throw new Error() Chủ động tạo lỗi DevTools (breakpoint) Gỡ lỗi trực quan Error Object Cung cấp thông tin chi tiết về lỗi","các-hàm-thường-dùng#Các hàm thường dùng":"console.log(\"Xin chào, đây là log!\"); console.warn(\"Cảnh báo: dữ liệu đầu vào trống!\"); console.error(\"Lỗi nghiêm trọng!\"); console.table([{ name: \"An\", age: 20 }, { name: \"Bình\", age: 22 }]);\rKết quả sẽ hiển thị trực tiếp trong tab Console của DevTools (F12 trên Chrome/Edge).","cú-pháp#Cú pháp:":"try { // đoạn code có thể gây lỗi let result = JSON.parse('{\"name\":\"Ngọc\"}'); console.log(result.name); } catch (error) { console.error(\"Có lỗi xảy ra:\", error.message); } finally { console.log(\"Luôn chạy dù có lỗi hay không\"); }","giải-thích#Giải thích:":"try: chứa đoạn code có khả năng gây lỗi. catch: chạy khi xảy ra lỗi. Có thể truy cập chi tiết lỗi qua biến error. finally: luôn chạy, thường dùng để dọn dẹp tài nguyên.","giải-thích-1#Giải thích:":"Nếu đường dẫn API sai, fetch() sẽ ném lỗi. catch sẽ bắt lỗi và log ra console. finally vẫn chạy để thông báo hoàn tất.","kết-luận#Kết luận":"Lỗi là một phần tự nhiên của lập trình — nhưng biết cách debug và xử lý lỗi thông minh sẽ giúp bạn tiết kiệm hàng giờ làm việc và tạo ra phần mềm đáng tin cậy.\nMột lập trình viên giỏi không phải là người không bao giờ gặp lỗi, mà là người biết cách hiểu và sửa lỗi thật nhanh!","mẹo-nhỏ#Mẹo nhỏ":"Dùng console.log() để kiểm tra biến tại từng bước. Dùng console.time() và console.timeEnd() để đo thời gian chạy đoạn code. Dùng console.group() để nhóm log gọn gàng.","tài-liệu-tham-khảo#Tài liệu tham khảo":"MDN Web Docs – try…catch Chrome DevTools Guide JavaScript Error Reference"},"title":"Xử lý lỗi và gỡ lỗi trong JavaScript – Làm chủ Debugging \u0026 Error Handling"},"/blogcuatruc.github.io/blog/bai-2-collection-stream-trong-java/":{"data":{"":"","-lưu-ý-về-hiệu-năng-và-song-song#⚠️ Lưu ý về hiệu năng và song song":"stream() là nối tiếp (sequential). parallelStream() cho phép xử lý song song — tốt cho tập lớn nhưng cẩn thận với side-effects (tránh modify shared state). Streams tốt cho readability, nhưng không phải lúc nào cũng nhanh hơn vòng lặp truyền thống (tùy bản chất công việc và kích thước dữ liệu).","1-groupingby-và-mapping#1) groupingBy và mapping":"Lấy map: ngành → list tên sinh viên\nMap\u003cString, List\u003cString\u003e\u003e namesByMajor = students.stream() .collect(Collectors.groupingBy( Student::getMajor, Collectors.mapping(Student::getName, Collectors.toList()) ));","1-list-ví-dụ-arraylist#1. \u003ccode\u003eList\u003c/code\u003e (ví dụ: \u003ccode\u003eArrayList\u003c/code\u003e)":"List là danh sách có thứ tự, cho phép trùng phần tử.\nimport java.util.*; List\u003cString\u003e names = new ArrayList\u003c\u003e(); names.add(\"An\"); names.add(\"Binh\"); names.add(\"Chi\"); names.add(\"An\"); // cho phép trùng System.out.println(names); // [An, Binh, Chi, An]","2-flatmap-dùng-cho-nested-collections#2) flatMap dùng cho nested collections":"Giả sử bạn có List","2-set-ví-dụ-hashset#2. Set (ví dụ: HashSet)":"Set là tập hợp không cho phép trùng, không bảo đảm thứ tự (nếu cần thứ tự dùng LinkedHashSet).\nSet\u003cString\u003e unique = new HashSet\u003c\u003e(); unique.add(\"An\"); unique.add(\"Binh\"); unique.add(\"An\"); // sẽ bị bỏ System.out.println(unique); // ví dụ: [Binh, An]","3-map-ví-dụ-hashmap#3. Map (ví dụ: HashMap)":"Map lưu trữ cặp key-value, dùng để tra cứu theo khóa.\nMap\u003cString, Integer\u003e age = new HashMap\u003c\u003e(); age.put(\"An\", 21); age.put(\"Binh\", 22); System.out.println(age.get(\"An\")); // 21","3-tổng-trung-bình-thống-kê#3) Tổng, trung bình, thống kê":"DoubleSummaryStatistics stats = students.stream() .collect(Collectors.summarizingDouble(Student::getGpa)); System.out.println(stats.getAverage()); // trung bình GPA","biên-dịch-và-chạy#Biên dịch và chạy:":"javac ExampleStream.java java ExampleStream","bài-tập-thực-hành-3-bài#Bài tập thực hành (3 bài)":"Viết chương trình đếm số từ độc nhất trong 1 danh sách List (không phân biệt hoa thường). Từ danh sách Student (có major và gpa), lấy top 3 sinh viên có GPA cao nhất trong ngành CS. Tạo Map","các-thao-tác-thường-dùng#Các thao tác thường dùng":"filter(predicate) — lọc phần tử map(func) — biến đổi từng phần tử flatMap(...) — nối nhiều stream con thành 1 distinct() — loại trùng sorted() / sorted(comparator) — sắp xếp limit(n) / skip(n) — lấy hoặc bỏ collect(Collectors.toList()) / toSet() / toMap() — thu thập kết quả","duyệt-một-list-bằng-vòng-lặp-for#Duyệt một List bằng vòng lặp for:":"for (String n : names) { System.out.println(n); }","giả-sử-có-class-student#Giả sử có class Student:":"public class Student { private String name; private double gpa; private String major; // constructor, getters, toString }","kết-luận#Kết luận":"Collection + Stream là công cụ không thể thiếu trong Java hiện đại. Nắm vững chúng giúp bạn xử lý dữ liệu nhanh chóng, code ngắn gọn và dễ bảo trì.\nỞ bài tiếp theo, chúng ta sẽ bàn về xử lý ngoại lệ (Exception) và logging trong Java — rất cần thiết khi ứng dụng bạn lớn dần.","mẹo--best-practices#Mẹo \u0026amp; Best Practices":"Dùng Stream để viết ngắn gọn và dễ đọc; tránh side-effects trong map/filter. Dùng Collectors.toMap() cẩn thận khi keys có thể trùng — cần cung cấp merge function. Khi cần performance tuning, đo đạc (benchmark) trước khi chuyển sang parallelStream. Sử dụng Optional để tránh NullPointerException khi lấy kết quả từ stream.","một-số-ví-dụ-nâng-cao#Một số ví dụ nâng cao":"","mở-đầu#Mở đầu":"Khi lập trình bằng Java, bạn sẽ rất thường xuyên thao tác với tập hợp dữ liệu — danh sách người, tập khóa, bảng mapping. Java cung cấp Collection Framework để quản lý các cấu trúc này, và Stream API (từ Java 8) để xử lý dữ liệu theo phong cách hàm, ngắn gọn và dễ đọc.\nTrong bài này bạn sẽ học:\nCác collection phổ biến: List, Set, Map Các thao tác cơ bản: thêm, xóa, tìm, duyệt Stream API: filter, map, sorted, collect, groupingBy, flatMap Ví dụ thực tế và cách chạy","phần-1--các-collection-cơ-bản#Phần 1 — Các Collection cơ bản":"","phần-2--duyệt-và-thao-tác-truyền-thống-imperative#Phần 2 — Duyệt và thao tác truyền thống (imperative)":"","phần-3--stream-api-phong-cách-hàm#Phần 3 — Stream API (phong cách hàm)":"Stream cho phép xử lý tập dữ liệu theo pipeline: source → intermediate ops → terminal op\nVí dụ: lọc, chuyển đổi, sắp xếp, thu thập kết quả.","sử-dụng-iterator#Sử dụng iterator:":"Iterator\u003cString\u003e it = names.iterator(); while (it.hasNext()) { String n = it.next(); if (n.equals(\"An\")) it.remove(); // xóa an toàn khi duyệt }","tham-khảo--đọc-tiếp#Tham khảo \u0026amp; đọc tiếp":"Stream API (Java 8) — java.util.stream Các Collector hữu ích: groupingBy, partitioningBy, mapping, summarizingDouble","thực-hành--ví-dụ-đầy-đủ-chạy-được#Thực hành — ví dụ đầy đủ (chạy được)":"","tạo-dữ-liệu-mẫu-và-sử-dụng-stream#Tạo dữ liệu mẫu và sử dụng Stream:":"List\u003cStudent\u003e students = List.of( new Student(\"An\", 3.2, \"CS\"), new Student(\"Binh\", 2.8, \"IT\"), new Student(\"Chi\", 3.7, \"CS\"), new Student(\"Dung\", 3.5, \"IT\") ); // Lọc các sinh viên GPA \u003e= 3.0, sắp xếp giảm dần theo GPA List\u003cStudent\u003e top = students.stream() .filter(s -\u003e s.getGpa() \u003e= 3.0) .sorted(Comparator.comparingDouble(Student::getGpa).reversed()) .collect(Collectors.toList()); // Nhóm theo ngành và đếm số lượng Map\u003cString, Long\u003e countByMajor = students.stream() .collect(Collectors.groupingBy(Student::getMajor, Collectors.counting()));\rKết quả countByMajor có thể là {CS=2, IT=2}.","tạo-file-examplestreamjava#Tạo file ExampleStream.java:":"import java.util.*; import java.util.stream.*; public class ExampleStream { public static void main(String[] args) { List\u003cString\u003e names = Arrays.asList(\"An\",\"Binh\",\"Chi\",\"An\",\"Dung\",\"Huy\"); // 1. distinct + map + sorted List\u003cString\u003e processed = names.stream() .distinct() .map(String::toUpperCase) .sorted() .collect(Collectors.toList()); System.out.println(\"Processed: \" + processed); // 2. filter and count long aCount = names.stream().filter(n -\u003e n.startsWith(\"A\")).count(); System.out.println(\"Start with A: \" + aCount); // 3. grouping example Map\u003cInteger, List\u003cString\u003e\u003e byLength = names.stream() .collect(Collectors.groupingBy(String::length)); System.out.println(\"Grouped by length: \" + byLength); } }","ví-dụ-cơ-bản#Ví dụ cơ bản":"import java.util.*; import java.util.stream.*; List\u003cString\u003e names = List.of(\"An\", \"Binh\", \"Chi\", \"An\", \"Dung\"); // Lọc tên không trùng, chuyển thành chữ hoa, và thu về List List\u003cString\u003e result = names.stream() .distinct() .map(String::toUpperCase) .collect(Collectors.toList()); System.out.println(result); // [AN, BINH, CHI, DUNG]","ví-dụ-dùng-parallel#Ví dụ dùng parallel:":"long count = bigList.parallelStream().filter(x -\u003e expensiveCheck(x)).count();","ví-dụ-thực-tế-danh-sách-học-sinh-lọc-và-nhóm#Ví dụ thực tế: danh sách học sinh, lọc và nhóm":"","ví-dụ-đầu-ra-có-thể#Ví dụ đầu ra có thể:":"Processed: [AN, BINH, CHI, DUNG, HUY]\rStart with A: 2\rGrouped by length: {2=[An], 4=[Binh, Dung, Huy], 3=[Chi]}"},"title":"Hiểu Collection và Stream trong Java chỉ trong 15 phút"},"/blogcuatruc.github.io/blog/bai-3-exception-logging/":{"data":{"":"Giới thiệu\rKhông có chương trình nào chạy mãi mà không lỗi. Dù bạn viết Java backend, ứng dụng mạng, hay app desktop, sớm muộn gì cũng sẽ có lỗi xảy ra — file không tồn tại, mất kết nối mạng, chia cho 0, lỗi định dạng dữ liệu…\nĐó là lý do Java cung cấp cơ chế Exception Handling (xử lý ngoại lệ) để giúp chương trình:\nKhông bị crash đột ngột Thông báo lỗi có ý nghĩa Ghi lại log để debug sau này Phân loại Exception trong Java\rNhóm Đặc điểm Ví dụ Checked Exception Bắt buộc phải xử lý (compile-time) IOException, SQLException Unchecked Exception Không bắt buộc (runtime) NullPointerException, ArrayIndexOutOfBoundsException Error Không nên xử lý trong code OutOfMemoryError, StackOverflowError 📘 Checked Exception thường dùng cho các tình huống ngoại cảnh (mất file, mất mạng).\nUnchecked Exception là do lỗi lập trình logic (chia 0, null, index sai…).\nCấu trúc cơ bản try - catch - finally\rCú pháp:\ntry { // Mã có thể gây lỗi } catch (ExceptionType e) { // Xử lý lỗi } finally { // Luôn chạy dù có lỗi hay không }\rVí dụ :\npublic class ExampleTryCatch { public static void main(String[] args) { try { int x = 10 / 0; // lỗi chia cho 0 System.out.println(\"Không bao giờ in tới dòng này\"); } catch (ArithmeticException e) { System.err.println(\"Lỗi: Chia cho 0 không hợp lệ!\"); } finally { System.out.println(\"Luôn chạy khối finally.\"); } } }\rKết quả:\nLỗi: Chia cho 0 không hợp lệ! Luôn chạy khối finally.\rXử lý nhiều ngoại lệ\rBạn có thể bắt nhiều loại lỗi khác nhau trong cùng khối try:\ntry { int[] arr = {1, 2, 3}; System.out.println(arr[5]); // lỗi IndexOutOfBounds int x = 10 / 0; // lỗi Arithmetic } catch (ArrayIndexOutOfBoundsException e) { System.err.println(\"Truy cập mảng sai vị trí!\"); } catch (ArithmeticException e) { System.err.println(\"Lỗi chia cho 0!\"); } catch (Exception e) { System.err.println(\"Lỗi không xác định: \" + e.getMessage()); }\rLưu ý: luôn đặt catch (Exception e) cuối cùng, vì nó bao hàm tất cả lỗi con.\nNém và tạo Exception tùy chỉnh","best-practices#Best Practices":"Không nên để catch (Exception e) mà không xử lý gì. Ghi log có ngữ cảnh rõ ràng (logger.log(Level.SEVERE, \"Lỗi khi đọc file\", e)). Dùng framework logging chuyên nghiệp hơn khi dự án lớn: SLF4J, Log4j2, Lombok @Slf4j. Với ứng dụng mạng: log địa chỉ IP client, thời gian, loại request để dễ truy vết.","bài-tiếp-theo#Bài tiếp theo":"“Lập trình Socket cơ bản trong Java” — bạn sẽ học cách tạo client-server và gửi dữ liệu giữa hai máy tính.","bài-tập-gợi-ý#Bài tập gợi ý":"Viết chương trình đăng nhập: nếu người dùng nhập sai mật khẩu 3 lần, ném Exception TooManyAttemptsException. Tạo file log.txt và ghi log khi người dùng thực hiện thao tác (login, logout, thất bại). Sử dụng try-with-resources để đảm bảo file luôn được đóng.","cấp-độ-log-phổ-biến#Cấp độ Log phổ biến":"Cấp độ Ý nghĩa SEVERE Lỗi nghiêm trọng, cần can thiệp WARNING Cảnh báo tiềm ẩn INFO Thông tin chung CONFIG Thông tin cấu hình FINE / FINER / FINEST Dùng khi debug chi tiết","cấu-trúc-cơ-bản-try---catch---finally#Cấu trúc cơ bản try - catch - finally":"","dùng-throw-để-ném-lỗi-thủ-công#Dùng throw để ném lỗi thủ công:":"public void checkAge(int age) { if (age \u003c 18) throw new IllegalArgumentException(\"Chưa đủ 18 tuổi!\"); System.out.println(\"Đủ tuổi truy cập.\"); }","ghi-log-ra-file#Ghi log ra file":"try { FileHandler fh = new FileHandler(\"app.log\", true); logger.addHandler(fh); fh.setFormatter(new SimpleFormatter()); logger.info(\"Ghi log ra file app.log thành công!\"); } catch (Exception e) { e.printStackTrace(); }\rSau khi chạy, bạn sẽ thấy file app.log chứa toàn bộ lịch sử log của ứng dụng.","giới-thiệu#Giới thiệu":"","kết-quả-console#Kết quả (console):":"Thg 10 23, 2025 10:15:00 SA LoggingDemo main\rINFO: Ứng dụng bắt đầu...\rThg 10 23, 2025 10:15:00 SA LoggingDemo main\rSEVERE: Lỗi toán học xảy ra\rjava.lang.ArithmeticException: / by zero\r...\rWARNING: Ứng dụng kết thúc với cảnh báo.","logging-trong-java-javautillogging#Logging trong Java (java.util.logging)":"Khi ứng dụng lớn, bạn không thể chỉ System.out.println() để xem lỗi. Thay vào đó, dùng logging framework để:\nGhi log ra file, console, hoặc server Gắn cấp độ log: INFO, WARNING, SEVERE, v.v.","ném-và-tạo-exception-tùy-chỉnh#Ném và tạo Exception tùy chỉnh":"","phân-loại-exception-trong-java#Phân loại Exception trong Java":"","sử-dụng#Sử dụng:":"try { validate(\"abc\"); } catch (InvalidDataException e) { System.err.println(\"Dữ liệu không hợp lệ: \" + e.getMessage()); }","tạo-exception-riêng-cho-ứng-dụng#Tạo Exception riêng cho ứng dụng:":"public class InvalidDataException extends Exception { public InvalidDataException(String message) { super(message); } }","tổng-kết#Tổng kết":"Exception Handling giúp chương trình không bị crash đột ngột. Logging giúp theo dõi lỗi và hoạt động hệ thống. Hai kỹ thuật này kết hợp là nền tảng cho mọi ứng dụng Java thực tế — đặc biệt trong lập trình mạng, khi lỗi kết nối và dữ liệu là chuyện thường xuyên.","ví-dụ-tổng-hợp-đọc-file-an-toàn--log-lỗi#Ví dụ tổng hợp: đọc file an toàn + log lỗi":"import java.io.*; import java.util.logging.*; public class FileReaderExample { private static final Logger logger = Logger.getLogger(FileReaderExample.class.getName()); public static void main(String[] args) { try { FileHandler fh = new FileHandler(\"readfile.log\", true); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); readFile(\"data.txt\"); } catch (IOException e) { logger.severe(\"Không thể tạo file log!\"); } } static void readFile(String fileName) { try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { String line; while ((line = br.readLine()) != null) { logger.info(\"Đọc dòng: \" + line); } } catch (FileNotFoundException e) { logger.warning(\"Không tìm thấy file: \" + fileName); } catch (IOException e) { logger.severe(\"Lỗi đọc file: \" + e.getMessage()); } finally { logger.info(\"Hoàn tất đọc file.\"); } } }\rKhi chạy, nếu file data.txt không tồn tại, bạn sẽ thấy log trong console và trong file readfile.log.","ví-dụ-đơn-giản#Ví dụ đơn giản:":"import java.util.logging.*; public class LoggingDemo { private static final Logger logger = Logger.getLogger(LoggingDemo.class.getName()); public static void main(String[] args) { logger.info(\"Ứng dụng bắt đầu...\"); try { int x = 10 / 0; } catch (ArithmeticException e) { logger.log(Level.SEVERE, \"Lỗi toán học xảy ra\", e); } logger.warning(\"Ứng dụng kết thúc với cảnh báo.\"); } }","xử-lý-nhiều-ngoại-lệ#Xử lý nhiều ngoại lệ":""},"title":"Xử lý ngoại lệ và Logging trong Java"},"/blogcuatruc.github.io/blog/bai-4-java-socket-basic/":{"data":{"":"","bài-tiếp-theo#Bài tiếp theo":"“Xây dựng ứng dụng chat nhiều client với đa luồng trong Java” (bạn sẽ học cách mỗi client có một luồng riêng để giao tiếp song song với server!)","bài-tập-mở-rộng#Bài tập mở rộng":"Viết chương trình chat 2 chiều giữa client và server. Tạo server cho phép nhiều client kết nối cùng lúc (gợi ý: sử dụng Thread). Ghi log các tin nhắn client gửi vào file chat.log.","client-console#Client console:":"Kết nối tới server thành công!\rPhản hồi từ Server: Chào Client! Tôi đã nhận được tin nhắn của bạn.","cách-chạy-thử#Cách chạy thử":"Mở hai cửa sổ terminal.\nTrong cửa sổ thứ nhất, chạy Server:\njavac SimpleServer.java java SimpleServer\rTrong cửa sổ thứ hai, chạy Client:\njavac SimpleClient.java java SimpleClient\rQuan sát:\nServer hiển thị tin nhắn nhận từ Client Client nhận phản hồi từ Server","cách-hoạt-động#Cách hoạt động":"Server tạo ServerSocket(port) → luôn “lắng nghe” tại cổng đó. Client tạo Socket(host, port) → yêu cầu kết nối. Khi kết nối thành công, Server nhận được Socket riêng cho client. Hai bên có thể gửi và nhận dữ liệu qua luồng I/O.","giới-thiệu#Giới thiệu":"Lập trình mạng (Network Programming) là một phần quan trọng trong Java.\nNó cho phép các chương trình giao tiếp qua Internet hoặc mạng LAN, ví dụ như:\nChat app Web server Ứng dụng truyền file Hệ thống giao tiếp IoT Java hỗ trợ mạng rất mạnh thông qua Socket API — lớp nằm trong package java.net.","khái-niệm-cơ-bản-về-socket#Khái niệm cơ bản về Socket":"Socket là điểm cuối (endpoint) của kết nối hai chiều giữa hai tiến trình (process) qua mạng.\nMô hình đơn giản:\ngraph LR\rClient \u003c--\u003e Server\rVai trò Nhiệm vụ ServerSocket Chờ (listen) yêu cầu kết nối từ client Socket Đại diện cho kết nối giữa client và server InputStream / OutputStream Dùng để đọc / ghi dữ liệu","kết-quả-mẫu#Kết quả mẫu":"","một-vài-lưu-ý#Một vài lưu ý":"Cổng (port) thường chọn từ 1024 → 65535 (tránh trùng với dịch vụ hệ thống). Nếu bạn chạy nhiều lần mà báo lỗi “Address already in use”, chờ vài giây hoặc đổi cổng khác (ví dụ 8081). Dùng try-with-resources để tự động đóng socket sau khi dùng. Trong lập trình mạng thực tế, luôn cần xử lý Timeout, Multi-threading, và Error Logging.","phân-tích-luồng-hoạt-động#Phân tích luồng hoạt động":"Bước Thực hiện Mô tả 1 new ServerSocket(8080) Mở cổng và chờ kết nối 2 serverSocket.accept() Chờ client 3 new Socket(\"localhost\",8080) Client gửi yêu cầu 4 Hai bên trao đổi dữ liệu qua InputStream \u0026 OutputStream","server-console#Server console:":"Server đang lắng nghe tại cổng 8080...\rKết nối từ client: /127.0.0.1\rClient gửi: Xin chào Server!","sơ-đồ-minh-họa#Sơ đồ minh họa:":"sequenceDiagram\rparticipant C as Client\rparticipant S as Server\rS-\u003e\u003eS: ServerSocket(8080)\rNote right of S: Chờ kết nối...\rC-\u003e\u003eS: Socket(\"localhost\",8080)\rS-\u003e\u003eC: Kết nối thành công!\rC-\u003e\u003eS: Gửi \"Xin chào Server!\"\rS-\u003e\u003eC: Gửi \"Chào Client, tôi đã nhận được!\"","tổng-kết#Tổng kết":"ServerSocket dùng cho phía server để chờ kết nối. Socket dùng cho client hoặc mỗi kết nối server-client. Giao tiếp dựa trên luồng dữ liệu (I/O Stream). Đây là nền tảng để phát triển ứng dụng mạng, game online, hoặc API thủ công.","ví-dụ-1-server-đơn-giản#Ví dụ 1: Server đơn giản":"// File: SimpleServer.java import java.io.*; import java.net.*; public class SimpleServer { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { System.out.println(\"Server đang lắng nghe tại cổng 8080...\"); Socket socket = serverSocket.accept(); System.out.println(\"Kết nối từ client: \" + socket.getInetAddress()); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); String message = in.readLine(); System.out.println(\"Client gửi: \" + message); out.println(\"Chào Client! Tôi đã nhận được tin nhắn của bạn.\"); socket.close(); } catch (IOException e) { System.err.println(\"Lỗi server: \" + e.getMessage()); } } }","ví-dụ-2-client-kết-nối-tới-server#Ví dụ 2: Client kết nối tới Server":"// File: SimpleClient.java import java.io.*; import java.net.*; public class SimpleClient { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)) { System.out.println(\"Kết nối tới server thành công!\"); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(\"Xin chào Server!\"); String response = in.readLine(); System.out.println(\"Phản hồi từ Server: \" + response); } catch (IOException e) { System.err.println(\"Lỗi client: \" + e.getMessage()); } } }"},"title":"Lập trình Socket cơ bản trong Java"},"/blogcuatruc.github.io/blog/bai-5-da-luong/":{"data":{"1-giới-thiệu-thread--runnable#1. Giới thiệu Thread \u0026amp; Runnable":"Trong Java, mỗi Thread là một luồng xử lý riêng biệt.\nKhi có nhiều client cùng kết nối, ta dùng nhiều luồng để server xử lý song song, tránh tình trạng “nghẽn”.\nVí dụ đơn giản:\nclass MyThread extends Thread { public void run() { System.out.println(\"Luồng đang chạy: \" + Thread.currentThread().getName()); } } public class DemoThread { public static void main(String[] args) { for (int i = 1; i \u003c= 3; i++) { new MyThread().start(); } } }\rKết quả: Chương trình in ra 3 luồng chạy gần như cùng lúc.","2-xây-dựng-server-đa-luồng#2. Xây dựng Server đa luồng":"","3-cách-chạy-thử#3. Cách chạy thử":"Mở nhiều cửa sổ terminal (1 server + 2 hoặc 3 client).\nTrong cửa sổ 1 (Server):\njavac ChatServer.java java ChatServer\rTrong cửa sổ 2 (Client 1):\njavac ChatClient.java java ChatClient\rTrong cửa sổ 3 (Client 2):\njava ChatClient","4-phân-tích-hoạt-động#4. Phân tích hoạt động":"Bước Thực hiện Mô tả 1 new ServerSocket(8080) Mở cổng lắng nghe 2 serverSocket.accept() Chờ client kết nối 3 Mỗi client → new Thread Xử lý song song 4 broadcast() Gửi tin nhắn tới tất cả client đang kết nối","5-lưu-ý--mở-rộng#5. Lưu ý \u0026amp; mở rộng":"Dùng synchronized để tránh xung đột khi nhiều luồng ghi dữ liệu. Có thể thêm tên người dùng (username) để hiển thị đẹp hơn. Có thể nâng cấp lên GUI Chat App với Swing hoặc JavaFX. Để server hỗ trợ ngắt kết nối mềm, cần thêm socket.close() đúng cách.","bài-5-giao-tiếp-đa-luồng-trong-lập-trình-mạng-java#Bài 5: Giao tiếp đa luồng trong lập trình mạng Java":"Bài 5: Giao tiếp đa luồng trong lập trình mạng Java","bài-tiếp-theo#Bài tiếp theo":"“Giao tiếp Server – Client bằng Object Stream (truyền đối tượng trong Java)”","bài-tập-mở-rộng#Bài tập mở rộng":"Thêm tính năng đặt tên người dùng khi client kết nối. Ghi lại toàn bộ tin nhắn vào file chat.log. Nâng cấp giao diện bằng Swing: tạo cửa sổ chat, danh sách người online. Tạo “Private Chat” – gửi tin nhắn riêng cho từng client.","client-1#Client 1:":"Chào bạn! Nhập 'exit' để thoát.\rNgười dùng: Ai đang ở đây không?\rNgười dùng: Mình đây nè!","client-2#Client 2:":"Chào bạn! Nhập 'exit' để thoát.\rNgười dùng: Xin chào!\rNgười dùng: Ai đang ở đây không?","clientjava#Client.java":"import java.io.*; import java.net.*; public class ChatClient { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in))) { System.out.println(\"Đã kết nối tới server chat!\"); new Thread(() -\u003e { try { String serverMsg; while ((serverMsg = in.readLine()) != null) { System.out.println(serverMsg); } } catch (IOException e) { System.out.println(\"Mất kết nối tới server.\"); } }).start(); String input; while ((input = userInput.readLine()) != null) { out.println(input); if (input.equalsIgnoreCase(\"exit\")) break; } } catch (IOException e) { System.out.println(\"Không thể kết nối tới server.\"); } } }","kết-quả-mẫu#Kết quả mẫu":"","mục-tiêu#Mục tiêu":"Mở rộng ứng dụng mạng để cho phép nhiều client kết nối và trò chuyện song song với nhau.","nội-dung-chính#Nội dung chính":"Giới thiệu Thread và Runnable trong Java Tạo Server đa luồng (Multi-threaded Server) Quản lý nhiều client cùng lúc Minh họa: Ứng dụng Chat mini như Messenger","server-console#Server console:":"Server chat đang chạy trên cổng 8080...\rKết nối mới từ: /127.0.0.1\rTừ client: Xin chào!\rTừ client: Ai đang ở đây không?","serverjava#Server.java":"import java.io.*; import java.net.*; import java.util.*; public class ChatServer { private static final int PORT = 8080; private static Set\u003cPrintWriter\u003e clientWriters = new HashSet\u003c\u003e(); public static void main(String[] args) { System.out.println(\"Server chat đang chạy trên cổng \" + PORT + \"...\"); try (ServerSocket serverSocket = new ServerSocket(PORT)) { while (true) { Socket clientSocket = serverSocket.accept(); System.out.println(\"Kết nối mới từ: \" + clientSocket.getInetAddress()); new ClientHandler(clientSocket).start(); } } catch (IOException e) { e.printStackTrace(); } } static class ClientHandler extends Thread { private Socket socket; private PrintWriter out; private BufferedReader in; public ClientHandler(Socket socket) { this.socket = socket; } public void run() { try { in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream(), true); synchronized (clientWriters) { clientWriters.add(out); } out.println(\"Chào bạn! Nhập 'exit' để thoát.\"); String message; while ((message = in.readLine()) != null) { if (message.equalsIgnoreCase(\"exit\")) break; System.out.println(\"Từ client: \" + message); broadcast(\"Người dùng: \" + message); } } catch (IOException e) { System.out.println(\"Lỗi kết nối client.\"); } finally { try { socket.close(); } catch (IOException e) {} synchronized (clientWriters) { clientWriters.remove(out); } System.out.println(\"Một client đã ngắt kết nối.\"); } } private void broadcast(String message) { synchronized (clientWriters) { for (PrintWriter writer : clientWriters) { writer.println(message); } } } } }","tổng-kết#Tổng kết":"ServerSocket lắng nghe kết nối. Mỗi client → một Thread xử lý riêng biệt. synchronized đảm bảo an toàn dữ liệu khi nhiều luồng truy cập. Đây là nền tảng của các ứng dụng chat đa người dùng, game online, hoặc hệ thống giao tiếp theo thời gian thực.","ý-tưởng#Ý tưởng":"Mỗi khi có client kết nối → Server tạo một luồng riêng để giao tiếp với client đó. Các client gửi tin nhắn, server sẽ phát lại (broadcast) cho tất cả những client khác."},"title":"Tạo server đa luồng bằng Java – Chat nhiều người như Messenger mini"},"/blogcuatruc.github.io/blog/bai-6-ket-noi-java-voi-mysql/":{"data":{"":"","1-cài-đặt-mysql#1. Cài đặt MySQL":"Tải và cài đặt MySQL Server + MySQL Workbench. Tạo cơ sở dữ liệu ví dụ: CREATE DATABASE chat_app; USE chat_app; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50), message TEXT );","1-thêm-dữ-liệu-insert#1. Thêm dữ liệu (INSERT)":"import java.sql.*; public class InsertUser { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; String sql = \"INSERT INTO users (username, message) VALUES (?, ?)\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(sql)) { stmt.setString(1, \"Nguyen\"); stmt.setString(2, \"Xin chào mọi người!\"); int rows = stmt.executeUpdate(); if (rows \u003e 0) { System.out.println(\"Thêm dữ liệu thành công!\"); } } catch (SQLException e) { e.printStackTrace(); } } }","2-cài-đặt-mysql-connector#2. Cài đặt MySQL Connector":"Nếu dùng Maven, thêm dependency vào pom.xml:\nmysql mysql-connector-java 8.1.0 Nếu chạy bằng tay, tải file .jar tại https://dev.mysql.com/downloads/connector/j/ và thêm vào classpath của project.","2-truy-xuất-dữ-liệu-select#2. Truy xuất dữ liệu (SELECT)":"import java.sql.*; public class SelectUser { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; String sql = \"SELECT id, username, message FROM users\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery()) { while (rs.next()) { int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String message = rs.getString(\"message\"); System.out.println(id + \" | \" + username + \" | \" + message); } } catch (SQLException e) { e.printStackTrace(); } } }","bắt-đầu-nào#Bắt đầu nào!":"Trong các ứng dụng Java, việc lưu trữ và truy xuất dữ liệu thường được thực hiện thông qua cơ sở dữ liệu. JDBC (Java Database Connectivity) là API tiêu chuẩn giúp Java kết nối và giao tiếp với nhiều hệ quản trị cơ sở dữ liệu khác nhau, chẳng hạn như MySQL.\nBài viết này sẽ hướng dẫn bạn từ cơ bản đến thực hành cách kết nối Java với MySQL và thực hiện truy vấn dữ liệu.\nBạn sẽ học được:\nCấu trúc và thành phần của JDBC Cách kết nối Java với MySQL Thực hiện các thao tác cơ bản: SELECT, INSERT Ví dụ lưu thông tin người dùng hoặc lịch sử chat","cách-1-chạy-trong-ide-netbeans-intellij-eclipse#Cách 1: Chạy trong IDE (NetBeans, IntelliJ, Eclipse)":"Mở IDE Tạo Project Java Thêm mysql-connector-java.jar vào Libraries Biên dịch và chạy file .java","cách-2-chạy-bằng-dòng-lệnh#Cách 2: Chạy bằng dòng lệnh":"javac ConnectMySQL.java java -cp .;mysql-connector-java-8.1.0.jar ConnectMySQL","cấu-trúc-jdbc-gồm-4-thành-phần-chính#Cấu trúc JDBC gồm 4 thành phần chính:":"Driver – Cầu nối giữa Java và hệ quản trị CSDL\nVí dụ: MySQL có driver riêng là mysql-connector-java.jar.\nConnection – Đại diện cho một kết nối tới cơ sở dữ liệu.\nStatement / PreparedStatement – Dùng để gửi các câu lệnh SQL.\nResultSet – Chứa kết quả trả về khi thực hiện câu lệnh SELECT.\nSơ đồ hoạt động:\ngraph LR\rA[Java Application] --\u003e B[JDBC API]\rB --\u003e C[JDBC Driver]\rC --\u003e D[Database MySQL]","giải-thích#Giải thích:":"DriverManager.getConnection(...): tạo đối tượng Connection. jdbc:mysql://localhost:3306/chat_app: định nghĩa đường dẫn JDBC đến CSDL MySQL. Đừng quên conn.close() để đóng kết nối.","kết-luận#Kết luận":"Thông qua JDBC, Java có thể dễ dàng kết nối với MySQL và thực hiện các thao tác với dữ liệu như thêm, đọc, sửa, xóa. Việc hiểu rõ cách hoạt động của JDBC là nền tảng quan trọng để học các công nghệ nâng cao hơn như Hibernate hoặc JPA.","phần-1--tổng-quan-về-jdbc#Phần 1 — Tổng quan về JDBC":"JDBC là một giao diện lập trình ứng dụng (API) giúp Java có thể:\nKết nối với cơ sở dữ liệu (MySQL, PostgreSQL, SQL Server, v.v.) Gửi và thực thi các lệnh SQL (SELECT, INSERT, UPDATE, DELETE) Nhận kết quả trả về từ cơ sở dữ liệu","phần-2--chuẩn-bị-môi-trường#Phần 2 — Chuẩn bị môi trường":"","phần-3--kết-nối-mysql-bằng-jdbc#Phần 3 — Kết nối MySQL bằng JDBC":"Dưới đây là ví dụ Java cơ bản để kiểm tra kết nối thành công.\nimport java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class ConnectMySQL { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; try { Connection conn = DriverManager.getConnection(url, user, password); System.out.println(\"Kết nối thành công đến MySQL!\"); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }","phần-4--thực-hiện-truy-vấn-sql-cơ-bản#Phần 4 — Thực hiện truy vấn SQL cơ bản":"","phần-5--lưu-ý-khi-làm-việc-với-jdbc#Phần 5 — Lưu ý khi làm việc với JDBC":"Luôn đóng Connection, Statement, và ResultSet sau khi sử dụng. Dùng try-with-resources để đảm bảo tài nguyên được giải phóng tự động. Ưu tiên dùng PreparedStatement thay cho Statement để tránh SQL Injection. Kiểm tra driver MySQL tương thích với phiên bản JDK. Có thể sử dụng Connection Pooling (như HikariCP) để tối ưu hiệu suất cho ứng dụng lớn.","phần-6--ví-dụ-thực-tế-lưu-lịch-sử-chat#Phần 6 — Ví dụ thực tế: Lưu lịch sử chat":"import java.sql.*; import java.util.Scanner; public class ChatLogger { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; Scanner sc = new Scanner(System.in); System.out.print(\"Nhập tên người dùng: \"); String username = sc.nextLine(); System.out.print(\"Nhập tin nhắn: \"); String message = sc.nextLine(); String insertSql = \"INSERT INTO users (username, message) VALUES (?, ?)\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(insertSql)) { stmt.setString(1, username); stmt.setString(2, message); stmt.executeUpdate(); System.out.println(\"Tin nhắn đã được lưu thành công!\"); } catch (SQLException e) { e.printStackTrace(); } } }","phần-7--cách-chạy#Phần 7 — Cách chạy":"","tài-liệu-tham-khảo#Tài liệu tham khảo":"Tài liệu JDBC chính thức của Oracle MySQL Connector/J Guide W3Schools JDBC Tutorial Baeldung – JDBC Basics"},"title":"Kết nối Java với MySQL: Hướng dẫn JDBC cho người mới bắt đầu"},"/blogcuatruc.github.io/blog/bai-7-gioi-thieu-javascript/":{"data":{"":"","1-biến-variables#1. Biến (Variables)":"Dùng để lưu trữ dữ liệu tạm thời. Khai báo bằng let, const hoặc var.\nlet name = \"Truc\"; const age = 21; var city = \"Ho Chi Minh\";\rlet – dùng khi giá trị có thể thay đổi const – dùng khi giá trị cố định var – cú pháp cũ (nên tránh trong code hiện đại)","1-in-thông-báo-bằng-alert#1. In thông báo bằng alert()":"\u003cscript\u003e alert(\"Hello World!\"); \u003c/script\u003e\rKhi tải trang, trình duyệt sẽ hiển thị một hộp thoại nhỏ.","2-in-ra-bảng-console-bằng-consolelog#2. In ra bảng console bằng console.log()":"\u003cscript\u003e console.log(\"Hello World!\"); \u003c/script\u003e\rKết quả hiển thị trong Console tab của Developer Tools (F12).","2-kiểu-dữ-liệu-data-types#2. Kiểu dữ liệu (Data Types)":"Kiểu Ví dụ Mô tả Number 10, 3.14 Số học String \"Hello\" Chuỗi ký tự Boolean true, false Đúng / Sai Array [1, 2, 3] Danh sách Object { name: \"An\", age: 20 } Dạng từ khóa–giá trị Null / Undefined null, undefined Không có giá trị / chưa gán giá trị","3-kết-hợp-với-html#3. Kết hợp với HTML":"\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003ch2\u003eXin chào JavaScript!\u003c/h2\u003e \u003cbutton onclick=\"sayHello()\"\u003eNhấn tôi!\u003c/button\u003e \u003cscript\u003e function sayHello() { alert(\"Chào mừng bạn đến với JavaScript!\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","3-toán-tử-operators#3. Toán tử (Operators)":"let x = 10; let y = 5; console.log(x + y); // 15 console.log(x * y); // 50 console.log(x \u003e y); // true console.log(x === 10); // true","4-hàm-functions#4. Hàm (Functions)":"Hàm là khối mã có thể tái sử dụng.\nfunction greet(name) { console.log(\"Xin chào, \" + name + \"!\"); } greet(\"Trúc\"); // Kết quả: Xin chào, Trúc! Hoặc dùng arrow function (cú pháp hiện đại hơn):\nconst greet = name =\u003e console.log(`Xin chào, ${name}!`);","bắt-đầu-nào#Bắt đầu nào!":"Nếu HTML là bộ khung của một trang web, CSS là phần trang điểm giúp nó đẹp hơn, thì JavaScript (JS) chính là linh hồn khiến trang web “sống động” — có thể phản hồi người dùng, xử lý dữ liệu, và thay đổi nội dung mà không cần tải lại trang.\nJavaScript là ngôn ngữ lập trình chạy trên trình duyệt, giúp tạo ra trải nghiệm tương tác mà bạn vẫn thấy hằng ngày:\n🔹 Nút bấm bật/tắt menu,\n🔹 Form kiểm tra dữ liệu đầu vào,\n🔹 Ảnh chuyển động, hiệu ứng cuộn,\n🔹 Thông báo, trò chuyện, game trên web, v.v.","cách-1-nhúng-trực-tiếp-trong-html#Cách 1: Nhúng trực tiếp trong HTML":"\u003cscript\u003e console.log(\"Hello từ script trong HTML!\"); \u003c/script\u003e","cách-2-tách-file-js-riêng#Cách 2: Tách file .js riêng":"\u003cscript src=\"main.js\"\u003e\u003c/script\u003e\rVà trong main.js:\nconsole.log(\"Hello từ file riêng!\");","cách-3-chạy-trong-console-của-trình-duyệt#Cách 3: Chạy trong Console của trình duyệt":"Mở DevTools (F12 → Console) và gõ:\nalert(\"Xin chào thế giới!\");","javascript-khác-gì-với-java#JavaScript khác gì với Java?":"So sánh Java JavaScript Loại ngôn ngữ Biên dịch Thông dịch Chạy ở đâu Máy ảo JVM Trình duyệt Mục đích Ứng dụng backend, desktop Web frontend Cú pháp Nghiêm ngặt, hướng đối tượng hoàn chỉnh Linh hoạt, hướng đối tượng dựa trên prototype File .java .js Dù tên giống nhau, Java và JavaScript hoàn toàn khác nhau — giống như “car” và “carpet”.","kết-luận#Kết luận":"JavaScript là ngôn ngữ cốt lõi của web hiện đại, cho phép bạn:\nThêm tính năng tương tác, kiểm tra dữ liệu, hiệu ứng động. Là nền tảng để học React, Vue, Angular, hoặc Node.js. Là bước đầu tiên để trở thành Front-end Developer.","phần-1--javascript-là-gì#Phần 1 — JavaScript là gì?":"JavaScript là ngôn ngữ lập trình động, thông dịch, và đa nền tảng, được thiết kế để chạy trực tiếp trong trình duyệt.\nViết bằng file .js hoặc nhúng trực tiếp vào HTML. Được trình duyệt (browser) hiểu và thực thi ngay, không cần biên dịch như Java hay C++. Có thể thao tác với nội dung HTML thông qua DOM (Document Object Model).","phần-2--javascript-chạy-trong-trình-duyệt-như-thế-nào#Phần 2 — JavaScript chạy trong trình duyệt như thế nào?":"Khi bạn mở một trang web có JavaScript, trình duyệt sẽ:\nĐọc mã HTML Phân tích và tải file JS Chạy từng dòng mã JavaScript theo thứ tự Cập nhật giao diện (DOM) hoặc phản hồi người dùng Ví dụ, khi bạn bấm nút, JS có thể thay đổi nội dung trang mà không tải lại toàn bộ.\ngraph LR\rA[HTML Trang web] --\u003e B[Trình duyệt]\rB --\u003e C[JavaScript Engine V8, SpiderMonkey...]\rC --\u003e D[Thực thi mã JS]\rD --\u003e E[Thay đổi nội dung HTML / DOM]","phần-3--biến-kiểu-dữ-liệu-hàm-toán-tử#Phần 3 — Biến, kiểu dữ liệu, hàm, toán tử":"","phần-4--thực-hành-hello-world-đầu-tiên#Phần 4 — Thực hành \u0026ldquo;Hello World\u0026rdquo; đầu tiên":"","phần-5--cách-chạy-javascript#Phần 5 — Cách chạy JavaScript":"","tài-liệu-tham-khảo#Tài liệu tham khảo":"MDN Web Docs – JavaScript W3Schools – JavaScript Tutorial JavaScript.info – Modern JS Guide ECMAScript Specification"},"title":"JavaScript là gì? Cách nó làm cho trang web trở nên sống động"},"/blogcuatruc.github.io/blog/bai-8-dom-va-su-kien/":{"data":{"1-dom-là-gì#1. DOM là gì?":"Khi trình duyệt tải một trang HTML, nó sẽ biến toàn bộ cấu trúc của trang đó thành cây DOM (Document Object Model).\nDOM không chỉ là “nội dung” mà còn là “mô hình dữ liệu” để JavaScript truy cập, sửa đổi, hoặc thêm mới phần tử.","2-truy-cập-phần-tử-html#2. Truy cập phần tử HTML":"","3-thay-đổi-nội-dung-và-thuộc-tính#3. Thay đổi nội dung và thuộc tính":"JavaScript cho phép bạn thay đổi nội dung, màu sắc, hoặc thêm class cho phần tử.\nconst box = document.getElementById(\"title\"); box.textContent = \"Chào mừng đến với DOM!\"; box.style.backgroundColor = \"lightcoral\"; box.style.padding = \"10px\";\rKết quả: phần tử đổi nội dung và có nền màu đỏ nhạt.","4-sự-kiện-event-trong-javascript#4. Sự kiện (Event) trong JavaScript":"Sự kiện là bất kỳ hành động nào người dùng thực hiện: nhấp chuột, nhập dữ liệu, rê chuột, cuộn trang…","5-ví-dụ-nút-đổi-màu-nền#5. Ví dụ: Nút đổi màu nền":"","6-ví-dụ-nâng-cao-hiển-thị-thời-gian-thực#6. Ví dụ nâng cao: Hiển thị thời gian thực":"","7-cách-gắn-sự-kiện-trong-html-không-khuyến-khích#7. Cách gắn sự kiện trong HTML (không khuyến khích)":"Bạn có thể gắn sự kiện trực tiếp trong HTML:\n\u003cbutton onclick=\"alert('Xin chào!')\"\u003eBấm vào đây\u003c/button\u003e\rTuy nhiên, cách này khó quản lý khi dự án lớn.\nCách dùng addEventListener() (ở trên) là chuẩn hơn.","8-tóm-tắt-kiến-thức#8. Tóm tắt kiến thức":"Khái niệm Mô tả DOM Mô hình cây đại diện cho tài liệu HTML getElementById / querySelector Dùng để truy cập phần tử addEventListener Dùng để lắng nghe sự kiện Event Hành động của người dùng (click, input, …)","bài-8-dom-và-sự-kiện--làm-web-tương-tác#Bài 8. DOM và Sự kiện – Làm web tương tác":"Bài 8. DOM và Sự kiện – Làm web tương tác","cách-1-getelementbyid#Cách 1: getElementById()":"Truy cập phần tử thông qua id.\nconst title = document.getElementById(\"title\"); title.textContent = \"Xin chào, JavaScript!\";","cách-2-queryselector#Cách 2: querySelector()":"Truy cập phần tử bằng CSS selector (rất linh hoạt).\nconst desc = document.querySelector(\".desc\"); desc.style.color = \"blue\";","cách-3-queryselectorall#Cách 3: querySelectorAll()":"Trả về tất cả các phần tử khớp selector (NodeList).\nconst items = document.querySelectorAll(\"p\"); items.forEach(item =\u003e item.style.fontWeight = \"bold\");","cấu-trúc-dom-sẽ-trông-như-thế-này#Cấu trúc DOM sẽ trông như thế này:":"graph TD\rA[Document] --\u003e B[html]\rB --\u003e C[head]\rB --\u003e D[body]\rD --\u003e E[h1 id=\"title\"]\rD --\u003e F[p class=\"desc\"]\rJavaScript có thể “đi vào” cây DOM để thay đổi bất kỳ phần tử nào.","html#HTML:":"\u003ch2\u003eThay đổi màu nền\u003c/h2\u003e \u003cbutton id=\"btn\"\u003eĐổi màu\u003c/button\u003e","html-1#HTML:":"\u003cp\u003eGiờ hiện tại: \u003cspan id=\"clock\"\u003e\u003c/span\u003e\u003c/p\u003e","javascript#JavaScript:":"const btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", function() { document.body.style.backgroundColor = document.body.style.backgroundColor === \"lightblue\" ? \"white\" : \"lightblue\"; });\rMỗi lần bạn bấm nút, trang sẽ đổi màu nền giữa trắng và xanh nhạt.","javascript-1#JavaScript:":"function updateClock() { const now = new Date(); const time = now.toLocaleTimeString(); document.getElementById(\"clock\").textContent = time; } setInterval(updateClock, 1000);\rKết quả: Đồng hồ chạy từng giây ngay trên trang web","kết-luận#Kết luận":"DOM và sự kiện là trái tim của lập trình web bằng JavaScript, nhờ có nó:\nGiao diện thay đổi linh hoạt mà không cần tải lại trang. Trang web phản ứng với từng hành động người dùng. Trong bài tiếp theo, bạn sẽ học cách để JavaScript giao tiếp với server — tải dữ liệu, hiển thị bài viết, hoặc gửi yêu cầu API bằng Fetch API và JSON.","một-số-sự-kiện-phổ-biến#Một số sự kiện phổ biến:":"Sự kiện Mô tả click Khi người dùng nhấp chuột mouseover Khi con trỏ rê qua phần tử input Khi người dùng nhập dữ liệu change Khi giá trị đầu vào thay đổi keydown Khi người dùng nhấn phím","mục-tiêu#Mục tiêu":"Hiểu DOM (Document Object Model) là gì và vì sao nó quan trọng. Biết cách truy cập và thay đổi phần tử HTML bằng JavaScript. Làm quen với xử lý sự kiện (Event Handling) như click, input, change. Tự tay làm ví dụ tương tác như đổi màu nền hoặc hiển thị thời gian thực.","ví-dụ-html#Ví dụ HTML:":"\u003cbody\u003e \u003ch1 id=\"title\"\u003eXin chào!\u003c/h1\u003e \u003cp class=\"desc\"\u003eĐây là đoạn mô tả.\u003c/p\u003e \u003c/body\u003e"},"title":"DOM và Event trong JavaScript"},"/blogcuatruc.github.io/blog/bai-9-giao-tiep-mang-voi-javascript/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Ngày nay, các ứng dụng web hiện đại không chỉ hiển thị nội dung tĩnh mà còn trao đổi dữ liệu với server để cập nhật thông tin liên tục.\nJavaScript cung cấp công cụ mạnh mẽ để thực hiện việc này – đó là Fetch API.\nFetch API cho phép bạn gửi yêu cầu HTTP (GET, POST, PUT, DELETE, …) và nhận dữ liệu phản hồi từ server, thường ở định dạng JSON.","2-gửi-và-nhận-dữ-liệu-bằng-fetch-api#2. Gửi và nhận dữ liệu bằng Fetch API":"Cú pháp cơ bản:\nfetch(url, { method: \"GET\", // hoặc POST, PUT, DELETE... headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(data) // chỉ dùng khi gửi dữ liệu }) .then(response =\u003e response.json()) .then(data =\u003e console.log(data)) .catch(error =\u003e console.error(\"Lỗi:\", error));","3-làm-việc-với-json#3. Làm việc với JSON":"JSON (JavaScript Object Notation) là định dạng dữ liệu phổ biến nhất để trao đổi giữa frontend và backend.","4-ví-dụ-gọi-api-công-khai#4. Ví dụ: Gọi API công khai":"Chúng ta sẽ thử gọi API https://jsonplaceholder.typicode.com/posts, đây là một API giả lập miễn phí chứa danh sách bài viết.","5-kết-quả-minh-họa#5. Kết quả minh họa":"Khi chạy trang này, trình duyệt sẽ tự động gửi yêu cầu đến API và hiển thị 10 bài viết đầu tiên:\nBài viết 1: sunt aut facere repellat provident occaecati excepturi optio reprehenderit Bài viết 2: qui est esse Bài viết 3: ea molestias quasi exercitationem repellat qui ipsa sit aut … Mỗi bài viết được hiển thị trong một khung riêng.","6-tổng-kết#6. Tổng kết":"Khái niệm Ý nghĩa Fetch API Gửi/nhận dữ liệu HTTP qua JavaScript Promise Giúp xử lý thao tác bất đồng bộ JSON Định dạng dữ liệu phổ biến giữa client và server Fetch API là cầu nối giữa frontend và backend, giúp ứng dụng web trở nên động, phản hồi nhanh và thân thiện hơn với người dùng.","7-bài-tập-mở-rộng#7. Bài tập mở rộng":"Thêm chức năng hiển thị chi tiết bài viết khi click vào tiêu đề. Viết thêm form gửi dữ liệu POST để tạo bài viết mới lên API. Dùng async/await thay cho .then() để code gọn hơn.","giải-thích#Giải thích":"fetch() trả về Promise, cho phép xử lý bất đồng bộ. response.json() giúp chuyển phản hồi (response) từ server sang đối tượng JSON mà JS có thể sử dụng. catch() bắt lỗi nếu quá trình kết nối thất bại.","html#HTML":"\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eFetch API Demo\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: #fafafa; padding: 20px; } .post { background: white; margin-bottom: 15px; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } h2 { color: #2c3e50; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eDanh sách bài viết\u003c/h1\u003e \u003cdiv id=\"post-list\"\u003e\u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","javascript-file-scriptjs#JavaScript (file script.js)":"const postList = document.getElementById(\"post-list\"); fetch(\"https://jsonplaceholder.typicode.com/posts\") .then(response =\u003e response.json()) .then(posts =\u003e { posts.slice(0, 10).forEach(post =\u003e { const div = document.createElement(\"div\"); div.className = \"post\"; div.innerHTML = ` ${post.title} ${post.body}\n`; postList.appendChild(div); }); }) .catch(error =\u003e { postList.innerHTML = `Lỗi tải dữ liệu: ${error}\n`; });","ví-dụ-json-mẫu#Ví dụ JSON mẫu:":"{ \"id\": 1, \"title\": \"Bài viết đầu tiên\", \"body\": \"Nội dung bài viết...\", \"userId\": 1 }\rJavaScript có thể chuyển đổi giữa chuỗi và đối tượng JSON bằng:\nconst jsonString = JSON.stringify({ name: \"Truc\", age: 21 }); const obj = JSON.parse(jsonString);"},"title":"Kết nối server bằng Fetch API – Cách JavaScript trò chuyện với backend"}}