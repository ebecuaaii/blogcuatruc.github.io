{"/blogcuatruc.github.io/blog/":{"data":{"":"","-tất-cả-bài-viết#📚 Tất cả bài viết":"Dưới đây là các bài mình chia sẻ về Java và JavaScript."},"title":"Blog lập trình"},"/blogcuatruc.github.io/blog/bai-1-tong-quan-ve-java/":{"data":{"":"","câu-hỏi-gợi-mở#Câu hỏi gợi mở":"Bạn đã từng viết chương trình đầu tiên bằng Java chưa? Nếu chưa, hãy thử ví dụ “Hello World” phía trên nhé!\n📚 Tham khảo thêm\nTrang chủ Java Tài liệu chính thức của Oracle về Java SE","giải-thích-về-cú-pháp-sử-dụng#Giải thích về cú pháp sử dụng:":"public class HelloWorld: khai báo một lớp công khai tên là HelloWorld. public static void main(String[] args): phương thức chính — điểm bắt đầu khi chương trình chạy. System.out.println(...): in ra dòng chữ lên màn hình.","giới-thiệu#Giới thiệu":"Java là một trong những ngôn ngữ lập trình lâu đời và phổ biến nhất trong lĩnh vực phát triển phần mềm.\nRa đời năm 1995 bởi James Gosling tại Sun Microsystems, Java được thiết kế với phương châm “Write once, run anywhere” (Viết một lần, chạy mọi nơi).\nĐiều này có nghĩa là chương trình viết bằng Java có thể chạy trên bất kỳ nền tảng nào có cài đặt Java Virtual Machine (JVM).","kiến-trúc-của-java#Kiến trúc của Java":"Khi bạn chạy một chương trình Java, quá trình diễn ra như sau:\nMã nguồn (.java) được biên dịch thành bytecode (.class). JVM (Java Virtual Machine) đọc bytecode và thực thi trên máy thật. 📊 Sơ đồ tổng quát:","kết-luận#Kết luận":"Java vẫn giữ vị thế quan trọng nhờ tính ổn định, bảo mật và cộng đồng lớn mạnh.","trong-các-bài-tiếp-theo#Trong các bài tiếp theo":"Cấu trúc chương trình Java Lập trình hướng đối tượng (OOP) Kỹ thuật Java trong lập trình mạng","ví-dụ-đầu-tiên-với-java#Ví dụ đầu tiên với Java":"Cùng mình viết chương trình kinh điển “Hello, World!” trong Java nha:\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\"Xin chào, Java!\"); } }\rLưu ý :\nTên file phải là HelloWorld.java (trùng với tên class public). Cần cài JDK và thêm javac/java vào PATH. Cách biên dịch và chạy (terminal trên Windows / Linux / macOS):\nBiên dịch: javac HelloWorld.java\rChạy: java HelloWorld\rKết quả mong đợi:\nXin chào, Java!\rNếu gặp lỗi “javac: command not found” hoặc tương tự, cài JDK (ví dụ OpenJDK) và thiết lập PATH / JAVA_HOME.","đặc-điểm-nổi-bật-của-java#Đặc điểm nổi bật của Java":"Đặc điểm Mô tả Đa nền tảng Chạy được trên nhiều hệ điều hành (Windows, macOS, Linux, Android, v.v.) Hướng đối tượng Mọi thứ trong Java đều là đối tượng — giúp quản lý và tái sử dụng mã hiệu quả Bảo mật cao Có lớp kiểm soát truy cập mạnh và cơ chế sandbox để ngăn mã độc Thư viện phong phú Cung cấp hàng ngàn thư viện hỗ trợ mạng, giao diện, cơ sở dữ liệu, web, v.v. Hiệu suất ổn định JVM tối ưu hiệu năng qua JIT Compiler","ứng-dụng-thực-tế-của-java#Ứng dụng thực tế của Java":"Ứng dụng doanh nghiệp (Enterprise Java) Ứng dụng Android (Android SDK) Ứng dụng web (Spring Boot, JSP, Servlets) Điện toán đám mây (AWS, Azure) Hệ thống nhúng, phần mềm máy chủ"},"title":"Tổng quan về ngôn ngữ lập trình Java"},"/blogcuatruc.github.io/blog/bai-10-xu-ly-bat-dong-bo/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Khi làm việc với Fetch API, ta thường thấy cú pháp như sau:\nfetch(url) .then(response =\u003e response.json()) .then(data =\u003e console.log(data)) .catch(error =\u003e console.error(error));\rCách viết này hoạt động tốt, nhưng khi chuỗi thao tác phức tạp (nhiều .then() lồng nhau) thì code dễ rối. Giải pháp: async/await — cú pháp mới của ES2017 giúp xử lý Promise gọn gàng, dễ đọc như code đồng bộ.","2-cách-hoạt-động-của-asyncawait#2. Cách hoạt động của async/await":"async khai báo một hàm bất đồng bộ; hàm này luôn trả về Promise.\nawait chỉ dùng bên trong hàm async, giúp “tạm dừng” hàm cho đến khi Promise hoàn thành.\nVí dụ:\nasync function demo() { console.log(\"Bắt đầu...\"); const data = await fetch(\"https://jsonplaceholder.typicode.com/posts/1\"); const post = await data.json(); console.log(post); console.log(\"Kết thúc!\"); } demo();\rKết quả in ra theo thứ tự dễ đọc:\nBắt đầu...\r{ id: 1, title: \"...\", body: \"...\" }\rKết thúc!","3-gửi-dữ-liệu-bằng-fetch-post-request#3. Gửi dữ liệu bằng Fetch (POST request)":"Ví dụ minh họa gửi bài viết mới bằng fetch() kết hợp async/await.\nHTML:\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ePOST với Fetch API\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: #f7f9fc; padding: 20px; } form { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); max-width: 400px; margin-bottom: 30px; } input, textarea { width: 100%; margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; } button { background: #3498db; color: white; border: none; padding: 10px 15px; border-radius: 6px; cursor: pointer; } button:hover { background: #2980b9; } .result { background: #eaf6ff; padding: 15px; border-radius: 8px; max-width: 400px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eTạo bài viết mới\u003c/h1\u003e \u003cform id=\"postForm\"\u003e \u003cinput type=\"text\" id=\"title\" placeholder=\"Tiêu đề\" required /\u003e \u003ctextarea id=\"body\" placeholder=\"Nội dung\" rows=\"4\" required\u003e\u003c/textarea\u003e \u003cbutton type=\"submit\"\u003eGửi bài viết\u003c/button\u003e \u003c/form\u003e \u003cdiv id=\"result\" class=\"result\"\u003e\u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\rJavaScript (file script.js):\nconst form = document.getElementById(\"postForm\"); const result = document.getElementById(\"result\"); form.addEventListener(\"submit\", async (e) =\u003e { e.preventDefault(); const newPost = { title: document.getElementById(\"title\").value, body: document.getElementById(\"body\").value, userId: 1 }; try { // hiển thị trạng thái đang gửi (bài tập mở rộng gợi ý) result.innerHTML = `Đang gửi dữ liệu...\n`; const response = await fetch(\"https://jsonplaceholder.typicode.com/posts\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(newPost) }); const data = await response.json(); result.innerHTML = ` Bài viết đã được gửi! ID: ${data.id}\nTiêu đề: ${data.title}\nNội dung: ${data.body}\n`; } catch (error) { result.innerHTML = `Lỗi gửi dữ liệu: ${error}\n`; } });","4-phân-tích-hoạt-động#4. Phân tích hoạt động":"Bước Mô tả 1 Người dùng nhập tiêu đề và nội dung vào form 2 Khi bấm “Gửi bài viết”, JS ngăn reload trang (preventDefault()) 3 fetch() gửi dữ liệu dạng JSON đến API 4 Server phản hồi lại dữ liệu đã gửi (có ID mới) 5 Kết quả hiển thị ngay trên giao diện","5-ưu-điểm-của-asyncawait#5. Ưu điểm của async/await":"Dễ đọc — không cần nhiều .then() lồng nhau. Xử lý lỗi tự nhiên bằng try...catch. Phù hợp cho các tác vụ bất đồng bộ phức tạp (gọi API nối tiếp, upload file, chờ nhiều Promise…).","6-tổng-kết#6. Tổng kết":"Khái niệm Ý nghĩa async Định nghĩa hàm bất đồng bộ await Tạm dừng cho đến khi Promise hoàn tất try...catch Bắt lỗi dễ dàng trong code bất đồng bộ async/await giúp Fetch API trở nên trực quan và dễ dùng, là công cụ cần thiết cho ứng dụng web hiện đại.","7-bài-tập-luyện-tập#7. Bài tập luyện tập":"Hiển thị thông báo “Đang gửi dữ liệu…” khi chờ phản hồi (ví dụ đã thêm trong JS). Thêm nút “Làm mới danh sách bài viết” để gọi lại API và hiển thị bài mới nhất. Kết hợp GET và POST để tạo trang blog mini với JavaScript. Thử cải tiến: validate form, hiển thị spinner, và disable nút khi đang gửi. Với async/await, JavaScript không chỉ chạy nhanh mà còn “dễ đọc như văn xuôi” — mở ra cánh cửa cho lập trình web hiện đại!"},"title":"Xử lý bất đồng bộ với async/await – Viết code Fetch API gọn gàng hơn"},"/blogcuatruc.github.io/blog/bai-11-luu-du-lieu-tren-local-storage/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Khi bạn truy cập một trang web, liệu bạn có bao giờ tự hỏi vì sao trình duyệt có thể “nhớ” được tên đăng nhập, giỏ hàng, hoặc chế độ tối/sáng?\nCâu trả lời nằm ở Web Storage API — trong đó có Local Storage và Session Storage, cho phép JavaScript lưu dữ liệu tạm thời hoặc lâu dài ngay trong trình duyệt mà không cần server.","2-sự-khác-nhau-giữa-local-storage-và-session-storage#2. Sự khác nhau giữa Local Storage và Session Storage":"Tính năng Local Storage Session Storage Thời gian lưu Vĩnh viễn (cho đến khi bị xóa) Chỉ tồn tại trong phiên làm việc (tab) Kích thước tối đa Khoảng 5MB Khoảng 5MB Truy cập Dữ liệu vẫn còn sau khi đóng trình duyệt Mất khi đóng tab hoặc cửa sổ Phạm vi Mọi tab cùng domain Riêng từng tab","3-cách-sử-dụng-local-storage#3. Cách sử dụng Local Storage":"","4-cách-sử-dụng-session-storage#4. Cách sử dụng Session Storage":"Cú pháp tương tự Local Storage, nhưng dữ liệu sẽ mất khi đóng tab:\n// Lưu sessionStorage.setItem(\"cart\", JSON.stringify([\"Laptop\", \"Chuột\"])); // Lấy const cart = JSON.parse(sessionStorage.getItem(\"cart\")); console.log(cart); // [\"Laptop\", \"Chuột\"] // Xóa sessionStorage.removeItem(\"cart\"); // Xóa toàn bộ sessionStorage.clear();\rLưu ý: Session Storage cũng lưu dưới dạng chuỗi — dùng JSON.stringify / JSON.parse khi lưu đối tượng hoặc mảng.","5-ví-dụ-thực-tế-ghi-nhớ-chế-độ-giao-diện-darklight-mode#5. Ví dụ thực tế: Ghi nhớ chế độ giao diện (Dark/Light Mode)":"HTML:\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003eDark Mode Demo\u003c/title\u003e \u003cstyle\u003e :root { --bg: #ffffff; --text: #000000; } body { font-family: Arial, sans-serif; background: var(--bg); color: var(--text); transition: all 0.3s ease; text-align: center; padding: 50px; } button { background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; } button:hover { background: #2980b9; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e Chế độ giao diện\u003c/h1\u003e \u003cbutton id=\"toggleBtn\"\u003eChuyển chế độ\u003c/button\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\rJavaScript (script.js):\nconst btn = document.getElementById(\"toggleBtn\"); function applyTheme(theme) { if (theme === \"dark\") { document.documentElement.style.setProperty(\"--bg\", \"#121212\"); document.documentElement.style.setProperty(\"--text\", \"#ffffff\"); } else { document.documentElement.style.setProperty(\"--bg\", \"#ffffff\"); document.documentElement.style.setProperty(\"--text\", \"#000000\"); } } // Lấy chế độ đã lưu (Local Storage giữ vĩnh viễn) let currentTheme = localStorage.getItem(\"theme\") || \"light\"; applyTheme(currentTheme); btn.addEventListener(\"click\", () =\u003e { currentTheme = currentTheme === \"light\" ? \"dark\" : \"light\"; localStorage.setItem(\"theme\", currentTheme); applyTheme(currentTheme); });\rKhi người dùng chọn chế độ tối, lựa chọn sẽ được lưu trong Local Storage và được áp dụng lại khi mở trang sau này.","6-tổng-kết#6. Tổng kết":"API Mục đích Thời gian lưu Local Storage Lưu thông tin lâu dài (cài đặt, token, theme) Vĩnh viễn (cho đến khi xóa) Session Storage Lưu thông tin tạm thời (dữ liệu form, trạng thái tab) Khi tab còn mở","7-bài-tập-thực-hành#7. Bài tập thực hành":"Tạo ứng dụng “Ghi chú cá nhân” lưu ghi chú bằng Local Storage. Tạo form đăng nhập demo, lưu trạng thái đăng nhập tạm thời bằng Session Storage. Kết hợp Fetch API + Local Storage để cache dữ liệu API, giúp tải nhanh hơn khi người dùng mở lại trang. Thêm UI để xem/ xóa toàn bộ dữ liệu Local/Session Storage.","cú-pháp-cơ-bản#Cú pháp cơ bản":"// Lưu dữ liệu localStorage.setItem(\"username\", \"Ngọc Trúc\"); // Lấy dữ liệu const user = localStorage.getItem(\"username\"); console.log(user); // \"Ngọc Trúc\" // Xóa một mục localStorage.removeItem(\"username\"); // Xóa toàn bộ localStorage.clear();\rLưu ý: Dữ liệu được lưu ở dạng chuỗi (string). Nếu bạn muốn lưu đối tượng hoặc mảng, hãy chuyển sang JSON.\nconst settings = { theme: \"dark\", fontSize: 18 }; localStorage.setItem(\"settings\", JSON.stringify(settings)); const savedSettings = JSON.parse(localStorage.getItem(\"settings\")); console.log(savedSettings.theme); // dark","ví-dụ-lưu-trữ-thông-tin-người-dùng#Ví dụ: Lưu trữ thông tin người dùng":"const user = { name: \"Ngọc Trúc\", email: \"ngoc.truc@example.com\" }; localStorage.setItem(\"user\", JSON.stringify(user)); const savedUser = JSON.parse(localStorage.getItem(\"user\")); console.log(savedUser.name); // \"Ngọc Trúc\""},"title":"Lưu dữ liệu trên trình duyệt với Local Storage và Session Storage"},"/blogcuatruc.github.io/blog/bai-12-xu-ly-loi-va-go-loi/":{"data":{"":"","-tài-liệu-tham-khảo#🔗 Tài liệu tham khảo":"MDN Web Docs – try…catch Chrome DevTools Guide","1-giới-thiệu#1. Giới thiệu":"Không lập trình viên nào tránh khỏi lỗi. Dù bạn là người mới học hay đã có kinh nghiệm, việc biết gỡ lỗi (debugging) và xử lý lỗi (error handling) là kỹ năng bắt buộc để viết phần mềm ổn định và đáng tin cậy.\nTrong JavaScript, ta có rất nhiều cách để phát hiện, theo dõi và khắc phục lỗi, bao gồm:\nSử dụng Console API để kiểm tra biến, log dữ liệu. Dùng try…catch…finally để xử lý ngoại lệ. Hiểu các loại lỗi phổ biến và cách tránh chúng. Dùng DevTools của trình duyệt để debug từng bước.","2-dò-lỗi-bằng-console#2. Dò lỗi bằng Console":"console là công cụ thân quen của mọi lập trình viên web.","3-các-loại-lỗi-phổ-biến-trong-javascript#3. Các loại lỗi phổ biến trong JavaScript":"Loại lỗi Nguyên nhân Ví dụ SyntaxError Sai cú pháp if (x \u003e 5 { ReferenceError Biến chưa được định nghĩa console.log(userName); // userName chưa khai báo TypeError Gọi sai kiểu dữ liệu \"hello\".push(\"!\") RangeError Giá trị nằm ngoài phạm vi (12345).toFixed(200) NetworkError Lỗi khi gọi API fetch(\"https://wrong-url.com\")","4-xử-lý-lỗi-bằng-trycatchfinally#4. Xử lý lỗi bằng try..catch..finally":"","5-tự-tạo-lỗi-với-throw#5. Tự tạo lỗi với throw":"Bạn có thể chủ động ném lỗi khi dữ liệu không hợp lệ:\nfunction divide(a, b) { if (b === 0) { throw new Error(\"Không thể chia cho 0!\"); } return a / b; } try { console.log(divide(10, 0)); } catch (e) { console.error(\"Lỗi:\", e.message); }","6-debug-từng-bước-bằng-devtools#6. Debug từng bước bằng Devtools":"Mở DevTools (F12) → tab Sources → đặt breakpoint ở dòng bạn muốn dừng.\nSau đó:\nNhấn F10 để chạy từng dòng.\nNhấn F8 để tiếp tục chương trình.\nQuan sát giá trị biến trong Scope.\nCách này cực hữu ích khi chương trình dài hoặc lỗi không rõ nguyên nhân.","7-ví-dụ-thực-tế-debug-lỗi-khi-gọi-api#7. Ví dụ thực tế Debug lỗi khi gọi API":"async function fetchPosts() { try { console.log(\"Đang gọi API...\"); const res = await fetch(\"https://jsonplaceholder.typicode.com/postsss\"); // lỗi URL if (!res.ok) throw new Error(\"Lỗi kết nối API!\"); const data = await res.json(); console.table(data.slice(0, 3)); } catch (err) { console.error(\"Không thể tải dữ liệu:\", err.message); } finally { console.log(\"Kết thúc quá trình fetch.\"); } } fetchPosts();\rGiải thích:\nNếu đường dẫn API sai, fetch() sẽ ném lỗi.\ncatch sẽ bắt lỗi và log ra console.\nfinally vẫn chạy để thông báo hoàn tất.","8-thực-hành-nhanh#8. Thực hành nhanh":"Viết chương trình nhập số chia (a, b), xử lý lỗi chia cho 0.\nThử ném lỗi khi JSON không hợp lệ (JSON.parse(’{name:“An”}’)).\nGọi API sai URL và xử lý lỗi mạng.\nĐặt breakpoint và debug từng dòng trong DevTools.","9-tổng-kết#9. Tổng kết":"Kỹ thuật Mục đích console.log / warn / error In thông tin ra console để theo dõi try...catch...finally Xử lý lỗi runtime throw new Error() Chủ động tạo lỗi DevTools (breakpoint) Gỡ lỗi trực quan Error Object Cung cấp thông tin chi tiết về lỗi Kết luận: Lỗi là một phần tự nhiên của lập trình — nhưng biết cách debug và xử lý lỗi thông minh sẽ giúp bạn tiết kiệm hàng giờ làm việc và tạo ra phần mềm đáng tin cậy.\nMột lập trình viên giỏi không phải là người không bao giờ gặp lỗi, mà là người biết cách hiểu và sửa lỗi thật nhanh!","các-hàm-thường-dùng#Các hàm thường dùng":"console.log(\"Xin chào, đây là log!\"); console.warn(\"Cảnh báo: dữ liệu đầu vào trống!\"); console.error(\"Lỗi nghiêm trọng!\"); console.table([{ name: \"An\", age: 20 }, { name: \"Bình\", age: 22 }]);","cú-pháp#Cú pháp:":"try { // đoạn code có thể gây lỗi let result = JSON.parse('{\"name\":\"Ngọc\"}'); console.log(result.name); } catch (error) { console.error(\"Có lỗi xảy ra:\", error.message); } finally { console.log(\"Luôn chạy dù có lỗi hay không\"); }\rGiải thích:\ntry: chứa đoạn code có khả năng gây lỗi.\ncatch: chạy khi xảy ra lỗi. Có thể truy cập chi tiết lỗi qua biến error.\nfinally: luôn chạy, thường dùng để dọn dẹp tài nguyên.","mẹo-nhỏ#Mẹo nhỏ":"Dùng console.log() để kiểm tra biến tại từng bước. Dùng console.time() và console.timeEnd() để đo thời gian chạy đoạn code. Dùng console.group() để nhóm log gọn gàng."},"title":"Xử lý lỗi và gỡ lỗi trong JavaScript – Làm chủ Debugging \u0026 Error Handling"},"/blogcuatruc.github.io/blog/bai-2-collection-stream-trong-java/":{"data":{"":"Bắt đầu nào !\rKhi lập trình bằng Java, bạn sẽ rất thường xuyên thao tác với tập hợp dữ liệu — danh sách người, tập khóa, bảng mapping. Java cung cấp Collection Framework để quản lý các cấu trúc này, và Stream API (từ Java 8) để xử lý dữ liệu theo phong cách hàm, ngắn gọn và dễ đọc.\nTrong bài này bạn sẽ học:\nCác collection phổ biến: List, Set, Map Các thao tác cơ bản: thêm, xóa, tìm, duyệt Stream API: filter, map, sorted, collect, groupingBy, flatMap Ví dụ thực tế và cách chạy Phần 1 — Các Collection cơ bản\r1. List (ví dụ: ArrayList)\rList là danh sách có thứ tự, cho phép trùng phần tử.\nimport java.util.*; List\u003cString\u003e names = new ArrayList\u003c\u003e(); names.add(\"An\"); names.add(\"Binh\"); names.add(\"Chi\"); names.add(\"An\"); // cho phép trùng System.out.println(names); // [An, Binh, Chi, An]\r2. Set (ví dụ: HashSet)\rSet là tập hợp không cho phép trùng, không bảo đảm thứ tự (nếu cần thứ tự dùng LinkedHashSet).\nSet\u003cString\u003e unique = new HashSet\u003c\u003e(); unique.add(\"An\"); unique.add(\"Binh\"); unique.add(\"An\"); // sẽ bị bỏ System.out.println(unique); // ví dụ: [Binh, An]\r3. Map (ví dụ: HashMap)\rMap là bảng mapping, mỗi phần tử có một key và một value.\nMap\u003cString, Integer\u003e scores = new HashMap\u003c\u003e(); scores.put(\"An\", 85); scores.put(\"Binh\", 90); scores.put(\"Chi\", 95); System.out.println(scores); // {An=85, Binh=90, Chi=95}\rPhần 2 — Duyệt và thao tác truyền thống (imperative)\rDưới đây là các cách phổ biến để duyệt và thao tác trên Collection theo phong cách thủ tục (imperative).\nVòng for-each (đọc, đơn giản)\rfor (String n : names) { System.out.println(n); }\rVòng for với chỉ số (khi cần index hoặc sửa đổi theo vị trí)\rfor (int i = 0; i \u003c names.size(); i++) { System.out.println(i + \": \" + names.get(i)); // names.set(i, names.get(i).toUpperCase()); // ví dụ sửa phần tử }\rIterator — xóa an toàn khi duyệt\rIterator\u003cString\u003e it = names.iterator(); while (it.hasNext()) { String n = it.next(); if (n.equals(\"An\")) { it.remove(); // xóa an toàn, tránh ConcurrentModificationException } }\rListIterator — duyệt hai chiều và sửa phần tử\rListIterator\u003cString\u003e lit = ((List\u003cString\u003e) names).listIterator(); while (lit.hasNext()) { String n = lit.next(); if (n.equals(\"Binh\")) { lit.set(\"Bình (updated)\"); // thay thế phần tử hiện tại } }\rremoveIf — xóa theo điều kiện (ngắn gọn, an toàn)\rnames.removeIf(n -\u003e n.equalsIgnoreCase(\"An\"));\rDuyệt Map — dùng entrySet để truy cập key và value hiệu quả\rMap\u003cString, Integer\u003e scores = new HashMap\u003c\u003e(); // ... populate ... for (Map.Entry\u003cString, Integer\u003e e : scores.entrySet()) { System.out.println(e.getKey() + \" -\u003e \" + e.getValue()); }\rHoặc (Java 8+) dùng forEach với lambda:\nscores.forEach((k, v) -\u003e System.out.println(k + \" =\u003e \" + v));\rLưu ý quan trọng\rKhông sửa cấu trúc collection (add/remove) trực tiếp trong for-each — dùng Iterator.remove() hoặc removeIf() để tránh ConcurrentModificationException. Khi thao tác đa luồng, đảm bảo đồng bộ hóa hoặc dùng collection thread-safe (ConcurrentHashMap, CopyOnWriteArrayList, v.v.). Khi cần hiệu năng cao với thao tác chỉ đọc, dùng for (index) trên ArrayList thường nhanh hơn Iterator. Phần 3 — Stream API (Java 8+)\rStream API cho phép xử lý dữ liệu theo phong cách hàm, ngắn gọn và dễ đọc. Các thao tác như filter, map, sorted, collect, groupingBy, flatMap đều có thể thực hiện trên Stream.\nVí dụ:\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); // Filter List\u003cString\u003e filtered = names.stream().filter(n -\u003e n.equals(\"An\")).collect(Collectors.toList()); System.out.println(filtered); // [An, An] // Map List\u003cString\u003e mapped = names.stream().map(n -\u003e n.toUpperCase()).collect(Collectors.toList()); System.out.println(mapped); // [AN, BINH, CHI, AN] // Sorted List\u003cString\u003e sorted = names.stream().sorted().collect(Collectors.toList()); System.out.println(sorted); // [An, An, Chi, Binh] // Collect Map\u003cString, Integer\u003e count = names.stream().collect(Collectors.groupingBy(String::toLowerCase, Collectors.counting())); System.out.println(count); // {an=2, chi=1, binh=1} // Grouping Map\u003cString, List\u003cString\u003e\u003e grouped = names.stream().collect(Collectors.groupingBy(String::toLowerCase)); System.out.println(grouped); // {an=[An, An], chi=[Chi], binh=[Binh]} // FlatMap List\u003cString\u003e flatMapped = names.stream().flatMap(n -\u003e Arrays.asList(n.split(\"\"))).collect(Collectors.toList()); System.out.println(flatMapped); // [An, An, Binh, Chi]\rCác method phổ biến:\rfilter: lọc phần tử theo điều kiện map: chuyển đổi phần tử sorted: sắp xếp collect: thu thập kết quả groupingBy: nhóm theo điều kiện flatMap: phẳng hóa (chuyển từ Stream thành Stream) Lưu ý\rStream là tạm thời, không thể thao tác trực tiếp (add/remove) — chỉ có thể thao tác trên các thao tác như filter, map, sorted, collect, groupingBy, flatMap. Stream có thể được tạo từ Collection, Array, hoặc từ một thao tác như generate, iterate. Stream API rất mạnh mẽ, nhưng cần hiểu rõ các khái niệm như terminal operation (các thao tác kết thúc như collect, forEach, count) và intermediate operation (các thao tác trung gian như filter, map, sorted). Phần 4 — Ví dụ thực tế\rVí dụ 1: Đếm số lượng mỗi phần tử trong danh sách\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); Map\u003cString, Integer\u003e count = names.stream().collect(Collectors.groupingBy(String::toLowerCase, Collectors.counting())); System.out.println(count); // {an=2, chi=1, binh=1}\rVí dụ 2: Nhóm các phần tử theo chữ cái đầu\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); Map\u003cString, List\u003cString\u003e\u003e grouped = names.stream().collect(Collectors.groupingBy(String::toLowerCase)); System.out.println(grouped); // {an=[An, An], chi=[Chi], binh=[Binh]}\rVí dụ 3: Chuyển đổi danh sách thành danh sách chữ hoa\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); List\u003cString\u003e mapped = names.stream().map(n -\u003e n.toUpperCase()).collect(Collectors.toList()); System.out.println(mapped); // [AN, BINH, CHI, AN]\rVí dụ 4: Lọc các phần tử trùng\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); List\u003cString\u003e filtered = names.stream().filter(n -\u003e n.equals(\"An\")).collect(Collectors.toList()); System.out.println(filtered); // [An, An]\rVí dụ 5: Sắp xếp danh sách\rList\u003cString\u003e names = Arrays.asList(\"An\", \"Binh\", \"Chi\", \"An\"); List\u003cString\u003e sorted = names.stream().sorted().collect(Collectors.toList()); System.out.println(sorted); // [An, An, Chi, Binh]\rPhần 5 — Cách chạy","1-list-ví-dụ-arraylist#1. \u003ccode\u003eList\u003c/code\u003e (ví dụ: \u003ccode\u003eArrayList\u003c/code\u003e)":"","2-set-ví-dụ-hashset#2. \u003ccode\u003eSet\u003c/code\u003e (ví dụ: \u003ccode\u003eHashSet\u003c/code\u003e)":"","3-map-ví-dụ-hashmap#3. \u003ccode\u003eMap\u003c/code\u003e (ví dụ: \u003ccode\u003eHashMap\u003c/code\u003e)":"","bắt-đầu-nào-#Bắt đầu nào !":"","các-method-phổ-biến#Các method phổ biến:":"","cách-1-chạy-trong-ide#Cách 1: Chạy trong IDE":"Mở IDE (như IntelliJ IDEA, Eclipse) Tạo một project Java Thêm các thư viện cần thiết (nếu có) Chạy chương trình","cách-2-chạy-từ-dòng-lệnh#Cách 2: Chạy từ dòng lệnh":"Mở terminal Chạy lệnh java -jar your-program.jar","cách-3-chạy-từ-file#Cách 3: Chạy từ file":"Mở file .java Chạy lệnh javac your-program.java Chạy lệnh java -jar your-program.jar","duyệt-map--dùng-entryset-để-truy-cập-key-và-value-hiệu-quả#Duyệt Map — dùng entrySet để truy cập key và value hiệu quả":"","iterator--xóa-an-toàn-khi-duyệt#Iterator — xóa an toàn khi duyệt":"","kết-luận#Kết luận":"Stream API là một công cụ mạnh mẽ để xử lý dữ liệu theo phong cách hàm. Nó giúp bạn viết code ngắn gọn, dễ đọc và dễ bảo trì. Tuy nhiên, cần hiểu rõ các khái niệm và cách sử dụng để tránh sai sót.","listiterator--duyệt-hai-chiều-và-sửa-phần-tử#ListIterator — duyệt hai chiều và sửa phần tử":"","lưu-ý#Lưu ý":"","lưu-ý-quan-trọng#Lưu ý quan trọng":"","phần-1--các-collection-cơ-bản#Phần 1 — Các Collection cơ bản":"","phần-2--duyệt-và-thao-tác-truyền-thống-imperative#Phần 2 — Duyệt và thao tác truyền thống (imperative)":"","phần-3--stream-api-java-8#Phần 3 — Stream API (Java 8+)":"","phần-4--ví-dụ-thực-tế#Phần 4 — Ví dụ thực tế":"","phần-5--cách-chạy#Phần 5 — Cách chạy":"","removeif--xóa-theo-điều-kiện-ngắn-gọn-an-toàn#removeIf — xóa theo điều kiện (ngắn gọn, an toàn)":"","tài-liệu-tham-khảo#Tài liệu tham khảo":"Java Collections Framework Java Stream API Java 8 Stream Examples Java 8 Stream API Guide","ví-dụ#Ví dụ:":"","ví-dụ-1-đếm-số-lượng-mỗi-phần-tử-trong-danh-sách#Ví dụ 1: Đếm số lượng mỗi phần tử trong danh sách":"","ví-dụ-2-nhóm-các-phần-tử-theo-chữ-cái-đầu#Ví dụ 2: Nhóm các phần tử theo chữ cái đầu":"","ví-dụ-3-chuyển-đổi-danh-sách-thành-danh-sách-chữ-hoa#Ví dụ 3: Chuyển đổi danh sách thành danh sách chữ hoa":"","ví-dụ-4-lọc-các-phần-tử-trùng#Ví dụ 4: Lọc các phần tử trùng":"","ví-dụ-5-sắp-xếp-danh-sách#Ví dụ 5: Sắp xếp danh sách":"","vòng-for-each-đọc-đơn-giản#Vòng for-each (đọc, đơn giản)":"","vòng-for-với-chỉ-số-khi-cần-index-hoặc-sửa-đổi-theo-vị-trí#Vòng for với chỉ số (khi cần index hoặc sửa đổi theo vị trí)":""},"title":"Hiểu Collection và Stream trong Java chỉ trong 15 phút"},"/blogcuatruc.github.io/blog/bai-3-exception-logging-java/":{"data":{"":"","-xử-lý-nhiều-ngoại-lệ#🧠 Xử lý nhiều ngoại lệ":"Bạn có thể bắt nhiều loại lỗi khác nhau trong cùng khối try:\ntry { int[] arr = {1, 2, 3}; System.out.println(arr[5]); // lỗi IndexOutOfBounds int x = 10 / 0; // lỗi Arithmetic } catch (ArrayIndexOutOfBoundsException e) { System.err.println(\"Truy cập mảng sai vị trí!\"); } catch (ArithmeticException e) { System.err.println(\"Lỗi chia cho 0!\"); } catch (Exception e) { System.err.println(\"Lỗi không xác định: \" + e.getMessage()); }\r⚠️ Lưu ý: luôn đặt catch (Exception e) cuối cùng, vì nó bao hàm tất cả lỗi con.\n✨ Ném và tạo Exception tùy chỉnh\nDùng throw để ném lỗi thủ công:\npublic void checkAge(int age) { if (age \u003c 18) throw new IllegalArgumentException(\"Chưa đủ 18 tuổi!\"); System.out.println(\"Đủ tuổi truy cập.\"); }\rTạo Exception riêng cho ứng dụng:\npublic class InvalidDataException extends Exception { public InvalidDataException(String message) { super(message); } }\rSử dụng:\ntry { validate(\"abc\"); } catch (InvalidDataException e) { System.err.println(\"Dữ liệu không hợp lệ: \" + e.getMessage()); }\r🧾 Logging trong Java (java.util.logging)\nKhi ứng dụng lớn, bạn không thể chỉ System.out.println() để xem lỗi. Thay vào đó, dùng logging framework để:\nGhi log ra file, console, hoặc server Gắn cấp độ log: INFO, WARNING, SEVERE, v.v. Ví dụ đơn giản:\nimport java.util.logging.*; public class LoggingDemo { private static final Logger logger = Logger.getLogger(LoggingDemo.class.getName()); public static void main(String[] args) { logger.info(\"Ứng dụng bắt đầu...\"); try { int x = 10 / 0; } catch (ArithmeticException e) { logger.log(Level.SEVERE, \"Lỗi toán học xảy ra\", e); } logger.warning(\"Ứng dụng kết thúc với cảnh báo.\"); } }\rKết quả (console) sẽ hiển thị các dòng INFO / SEVERE / WARNING kèm stacktrace.\n🪵 Ghi log ra file\ntry { FileHandler fh = new FileHandler(\"app.log\", true); logger.addHandler(fh); fh.setFormatter(new SimpleFormatter()); logger.info(\"Ghi log ra file app.log thành công!\"); } catch (Exception e) { e.printStackTrace(); }\rSau khi chạy, bạn sẽ thấy file app.log chứa toàn bộ lịch sử log của ứng dụng.\n⚙️ Cấp độ Log phổ biến\nSEVERE — Lỗi nghiêm trọng, cần can thiệp WARNING — Cảnh báo tiềm ẩn INFO — Thông tin chung CONFIG — Thông tin cấu hình FINE / FINER / FINEST — Dùng khi debug chi tiết 🧮 Ví dụ tổng hợp: đọc file an toàn + log lỗi\nimport java.io.*; import java.util.logging.*; public class FileReaderExample { private static final Logger logger = Logger.getLogger(FileReaderExample.class.getName()); public static void main(String[] args) { try { FileHandler fh = new FileHandler(\"readfile.log\", true); fh.setFormatter(new SimpleFormatter()); logger.addHandler(fh); readFile(\"data.txt\"); } catch (IOException e) { logger.severe(\"Không thể tạo file log!\"); } } static void readFile(String fileName) { try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { String line; while ((line = br.readLine()) != null) { logger.info(\"Đọc dòng: \" + line); } } catch (FileNotFoundException e) { logger.warning(\"Không tìm thấy file: \" + fileName); } catch (IOException e) { logger.severe(\"Lỗi đọc file: \" + e.getMessage()); } finally { logger.info(\"Hoàn tất đọc file.\"); } } }\rKhi chạy, nếu file data.txt không tồn tại, bạn sẽ thấy log trong console và trong file readfile.log.\n✅ Best Practices\nKhông nên để catch (Exception e) mà không xử lý gì. Ghi log có ngữ cảnh rõ ràng: logger.log(Level.SEVERE, \"Lỗi khi đọc file\", e). Dùng framework logging chuyên nghiệp hơn khi dự án lớn: SLF4J + Log4j2, hoặc Lombok @Slf4j. Với ứng dụng mạng: log địa chỉ IP client, thời gian, loại request để dễ truy vết. 🧠 Bài tập gợi ý\nViết chương trình đăng nhập: nếu người dùng nhập sai mật khẩu 3 lần, ném TooManyAttemptsException. Tạo file log.txt và ghi log khi người dùng thực hiện thao tác (login, logout, thất bại). Sử dụng try-with-resources để đảm bảo file luôn được đóng. 📚 Tổng kết\nException Handling giúp chương trình không bị crash đột ngột.\nLogging giúp theo dõi lỗi và hoạt động hệ thống.\nHai kỹ thuật này kết hợp là nền tảng cho mọi ứng dụng Java thực tế — đặc biệt trong lập trình mạng.\n🔜 Bài tiếp theo\n“Lập trình Socket cơ bản trong Java” — bạn sẽ học cách tạo client-server và gửi dữ liệu giữa hai máy tính.","cấu-trúc-cơ-bản-try---catch---finally#Cấu trúc cơ bản try - catch - finally":"Cú pháp:\ntry { // Mã có thể gây lỗi } catch (ExceptionType e) { // Xử lý lỗi } finally { // Luôn chạy dù có lỗi hay không }\rVí dụ:\npublic class ExampleTryCatch { public static void main(String[] args) { try { int x = 10 / 0; // lỗi chia cho 0 System.out.println(\"Không bao giờ in tới dòng này\"); } catch (ArithmeticException e) { System.err.println(\"Lỗi: Chia cho 0 không hợp lệ!\"); } finally { System.out.println(\"Luôn chạy khối finally.\"); } } }\rKết quả:\nLỗi: Chia cho 0 không hợp lệ!\rLuôn chạy khối finally.","giới-thiệu#Giới thiệu":"Không có chương trình nào chạy mãi mà không lỗi. Dù bạn viết Java backend, ứng dụng mạng, hay app desktop, sớm muộn gì cũng sẽ có lỗi xảy ra — file không tồn tại, mất kết nối mạng, chia cho 0, lỗi định dạng dữ liệu…\nĐó là lý do Java cung cấp cơ chế Exception Handling (xử lý ngoại lệ) để giúp chương trình:\nKhông bị crash đột ngột Thông báo lỗi có ý nghĩa Ghi lại log để debug sau này","phân-loại-exception-trong-java#Phân loại Exception trong Java":"Nhóm Đặc điểm Ví dụ Checked Exception Bắt buộc phải xử lý (compile-time) IOException, SQLException Unchecked Exception Không bắt buộc (runtime) NullPointerException, ArrayIndexOutOfBoundsException Error Không nên xử lý trong code OutOfMemoryError, StackOverflowError 📘 Checked Exception thường dùng cho các tình huống ngoại cảnh (mất file, mất mạng).\nUnchecked Exception là do lỗi lập trình logic (chia 0, null, index sai…)."},"title":"Xử lý ngoại lệ và Logging trong Java"},"/blogcuatruc.github.io/blog/bai-4-java-socket-basic/":{"data":{"":"","-bài-tiếp-theo#🔜 Bài tiếp theo":"👉 “Xây dựng ứng dụng chat nhiều client với đa luồng trong Java” — bạn sẽ học cách mỗi client có một luồng riêng để giao tiếp song song với server!","-bài-tập-mở-rộng#🧠 Bài tập mở rộng":"Viết chương trình chat 2 chiều giữa client và server. Tạo server cho phép nhiều client kết nối cùng lúc (gợi ý: sử dụng Thread hoặc ExecutorService). Ghi log các tin nhắn client gửi vào file chat.log.","-cách-chạy-thử#🧩 Cách chạy thử":"1.Mở hai cửa sổ terminal:\n2.Trong cửa sổ thứ nhất, chạy Server:\njavac SimpleServer.java java SimpleServer\r3.Trong cửa sổ thứ hai, chạy Client:\njavac SimpleClient.java java SimpleClient\r4.Quan sát:\nServer hiển thị tin nhắn nhận từ Client\nClient nhận phản hồi từ Server","-cách-hoạt-động#🧠 Cách hoạt động":"Server tạo ServerSocket(port) → luôn “lắng nghe” tại cổng đó. Client tạo Socket(host, port) → yêu cầu kết nối. Khi kết nối thành công, Server nhận được Socket riêng cho client. Hai bên có thể gửi và nhận dữ liệu qua luồng I/O. Sơ đồ minh họa:\nsequenceDiagram\rparticipant C as Client\rparticipant S as Server\rS-\u003e\u003eS: ServerSocket(8080)\rNote right of S: Chờ kết nối...\rC-\u003e\u003eS: Socket(\"localhost\",8080)\rS-\u003e\u003eC: Kết nối thành công!\rC-\u003e\u003eS: Gửi \"Xin chào Server!\"\rS-\u003e\u003eC: Gửi \"Chào Client, tôi đã nhận được!\"\rVí dụ 1: Server đơn giản\n// File: SimpleServer.java import java.io.*; import java.net.*; public class SimpleServer { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { System.out.println(\"🖥️ Server đang lắng nghe tại cổng 8080...\"); Socket socket = serverSocket.accept(); System.out.println(\"✅ Kết nối từ client: \" + socket.getInetAddress()); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); String message = in.readLine(); System.out.println(\"📩 Client gửi: \" + message); out.println(\"Chào Client! Tôi đã nhận được tin nhắn của bạn.\"); socket.close(); } catch (IOException e) { System.err.println(\"Lỗi server: \" + e.getMessage()); } } }\rVí dụ 2: Client kết nối tới Server\n// File: SimpleClient.java import java.io.*; import java.net.*; public class SimpleClient { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080)) { System.out.println(\"📡 Kết nối tới server thành công!\"); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(\"Xin chào Server!\"); String response = in.readLine(); System.out.println(\"📬 Phản hồi từ Server: \" + response); } catch (IOException e) { System.err.println(\"Lỗi client: \" + e.getMessage()); } } }","-giới-thiệu#🌐 Giới thiệu":"Lập trình mạng (Network Programming) là một phần quan trọng trong Java.\nNó cho phép các chương trình giao tiếp qua Internet hoặc mạng LAN, ví dụ như:\nChat app Web server Ứng dụng truyền file Hệ thống giao tiếp IoT Java hỗ trợ mạng rất mạnh thông qua Socket API — lớp nằm trong package java.net.","-khái-niệm-cơ-bản-về-socket#🔌 Khái niệm cơ bản về Socket":"📖 Socket là điểm cuối (endpoint) của kết nối hai chiều giữa hai tiến trình (process) qua mạng.\nMô hình đơn giản:\nHình minh họa mô hình Client–Server (nguồn: Internet)\nVai trò Nhiệm vụ ServerSocket Chờ (listen) yêu cầu kết nối từ client Socket Đại diện cho kết nối giữa client và server InputStream / OutputStream Dùng để đọc / ghi dữ liệu","-kết-quả-mẫu#📄 Kết quả mẫu":"Server console:\n🖥️ Server đang lắng nghe tại cổng 8080... ✅ Kết nối từ client: /127.0.0.1 📩 Client gửi: Xin chào Server!\rClient console:\n📡 Kết nối tới server thành công! 📬 Phản hồi từ Server: Chào Client! Tôi đã nhận được tin nhắn của bạn.","-một-vài-lưu-ý#💡 Một vài lưu ý":"Cổng (port) thường chọn từ 1024 → 65535 (tránh trùng với dịch vụ hệ thống). Nếu gặp “Address already in use”, chờ vài giây hoặc đổi cổng khác (ví dụ 8081). Dùng try-with-resources để tự động đóng socket sau khi dùng. Trong thực tế cần xử lý Timeout, đa luồng (Multi-threading), và logging lỗi.","-phân-tích-luồng-hoạt-động#⚙️ Phân tích luồng hoạt động":"Bước Thực hiện Mô tả 1 new ServerSocket(8080) Mở cổng và chờ kết nối 2 serverSocket.accept() Chờ client kết nối 3 new Socket(“localhost”,8080) Client gửi yêu cầu kết nối 4 I/O Streams Hai bên trao đổi dữ liệu qua InputStream \u0026 OutputStream","-tổng-kết#🚀 Tổng kết":"ServerSocket dùng cho phía server để chờ kết nối. Socket dùng cho client hoặc mỗi kết nối server-client. Giao tiếp dựa trên luồng dữ liệu (I/O Stream). Đây là nền tảng để phát triển ứng dụng mạng, game online, hoặc API thủ công."},"title":"Lập trình Socket cơ bản trong Java"},"/blogcuatruc.github.io/blog/bai-5-da-luong/":{"data":{"-kết-quả-mẫu#📄 Kết quả mẫu":"Server console:\nServer chat đang chạy trên cổng 8080... Kết nối mới từ: /127.0.0.1 Từ client: Xin chào! Từ client: Ai đang ở đây không?\rClient 1:\nChào bạn! Nhập 'exit' để thoát. User 1: Ai đang ở đây không? User 2: Mình đây nè!\rClient 2:\nChào bạn! Nhập 'exit' để thoát. User 1: Xin chào! User 1: Ai đang ở đây không?","1-giới-thiệu-thread--runnable#1. Giới thiệu Thread \u0026amp; Runnable":"Trong Java, mỗi Thread là một luồng xử lý riêng biệt.\nKhi có nhiều client cùng kết nối, ta dùng nhiều luồng để server xử lý song song, tránh tình trạng “nghẽn”.\nVí dụ đơn giản:\nclass MyThread extends Thread { public void run() { System.out.println(\"Luồng đang chạy: \" + Thread.currentThread().getName()); } } public class DemoThread { public static void main(String[] args) { for (int i = 1; i \u003c= 3; i++) { new MyThread().start(); } } }\rKết quả: Chương trình in ra 3 luồng chạy gần như cùng lúc.","2-xây-dựng-server-đa-luồng#2. Xây dựng Server đa luồng":"Ý tưởng\nMỗi khi có client kết nối → Server tạo một luồng riêng để giao tiếp với client đó.\nCác client gửi tin nhắn, server sẽ phát lại (broadcast) cho tất cả những client khác.\nServer.java\nimport java.io.*; import java.net.*; import java.util.*; public class ChatServer { private static final int PORT = 8080; private static Set\u003cPrintWriter\u003e clientWriters = new HashSet\u003c\u003e(); public static void main(String[] args) { System.out.println(\"🚀 Server chat đang chạy trên cổng \" + PORT + \"...\"); try (ServerSocket serverSocket = new ServerSocket(PORT)) { while (true) { Socket clientSocket = serverSocket.accept(); System.out.println(\"✅ Kết nối mới từ: \" + clientSocket.getInetAddress()); new ClientHandler(clientSocket).start(); } } catch (IOException e) { e.printStackTrace(); } } static class ClientHandler extends Thread { private Socket socket; private PrintWriter out; private BufferedReader in; public ClientHandler(Socket socket) { this.socket = socket; } public void run() { try { in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream(), true); synchronized (clientWriters) { clientWriters.add(out); } out.println(\"👋 Chào bạn! Nhập 'exit' để thoát.\"); String message; while ((message = in.readLine()) != null) { if (message.equalsIgnoreCase(\"exit\")) break; System.out.println(\"💬 Từ client: \" + message); broadcast(\"Người dùng: \" + message); } } catch (IOException e) { System.out.println(\"⚠️ Lỗi kết nối client.\"); } finally { try { socket.close(); } catch (IOException e) {} synchronized (clientWriters) { clientWriters.remove(out); } System.out.println(\"❌ Một client đã ngắt kết nối.\"); } } private void broadcast(String message) { synchronized (clientWriters) { for (PrintWriter writer : clientWriters) { writer.println(message); } } } } }\rClient.java\nimport java.io.*; import java.net.*; public class ChatClient { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 8080); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in))) { System.out.println(\"Đã kết nối tới server chat!\"); new Thread(() -\u003e { try { String serverMsg; while ((serverMsg = in.readLine()) != null) { System.out.println(serverMsg); } } catch (IOException e) { System.out.println(\" Mất kết nối tới server.\"); } }).start(); String input; while ((input = userInput.readLine()) != null) { out.println(input); if (input.equalsIgnoreCase(\"exit\")) break; } } catch (IOException e) { System.out.println(\" Không thể kết nối tới server.\"); } } }","3-cách-chạy-thử#3. Cách chạy thử":"Mở nhiều cửa sổ terminal (1 server + 2 hoặc 3 client).\nTrong cửa sổ 1 (Server):\njavac ChatServer.java java ChatServer\rTrong cửa sổ 2 (Client 1):\njavac ChatClient.java java ChatClient\rTrong cửa sổ 3 (Client 2):\njava ChatClient","4-phân-tích-hoạt-động#4. Phân tích hoạt động":"Bước Thực hiện Mô tả 1 new ServerSocket(8080) Mở cổng lắng nghe 2 serverSocket.accept() Chờ client kết nối 3 Mỗi client → new Thread Xử lý song song 4 broadcast() Gửi tin nhắn tới tất cả client đang kết nối","5-lưu-ý--mở-rộng#5. Lưu ý \u0026amp; mở rộng":"Dùng synchronized để tránh xung đột khi nhiều luồng truy cập clientWriters. Thêm username để hiển thị tin nhắn rõ ràng hơn. Nâng cấp giao diện bằng Swing/JavaFX nếu cần GUI. Thêm xử lý ngắt kết nối mềm và timeout cho socket. Lưu log (chat.log) và xoay log khi cần.","bài-tập-mở-rộng#Bài tập mở rộng":"Yêu cầu đặt tên người dùng khi client kết nối. Ghi toàn bộ tin nhắn vào chat.log. Thêm chế độ “Private Chat” (gửi tới 1 client cụ thể). Thử dùng ExecutorService thay vì tạo Thread thủ công.","giao-tiếp-đa-luồng-trong-lập-trình-mạng-java#Giao tiếp đa luồng trong lập trình mạng Java":"Giao tiếp đa luồng trong lập trình mạng Java","mục-tiêu#Mục tiêu":"Mở rộng ứng dụng mạng để cho phép nhiều client kết nối và trò chuyện song song với nhau.","nội-dung-chính#Nội dung chính":"Giới thiệu Thread và Runnable trong Java Tạo Server đa luồng (Multi-threaded Server) Quản lý nhiều client cùng lúc Minh họa: Ứng dụng Chat mini như Messenger","tổng-kết#Tổng kết":"ServerSocket lắng nghe kết nối. Mỗi client được xử lý bởi một luồng riêng. synchronized giúp bảo vệ dữ liệu chung. Đây là nền tảng để xây dựng chat đa người, game online, hoặc hệ thống realtime."},"title":"Tạo server đa luồng bằng Java – Chat nhiều người như Messenger mini"},"/blogcuatruc.github.io/blog/bai-6-ket-noi-java-voi-mysql/":{"data":{"":"","1-cài-đặt-mysql#1. Cài đặt MySQL":"Tải và cài đặt MySQL Server + MySQL Workbench. Tạo cơ sở dữ liệu ví dụ: CREATE DATABASE chat_app; USE chat_app; CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50), message TEXT );","2-cài-đặt-mysql-connector#2. Cài đặt MySQL Connector":"Nếu dùng Maven, thêm dependency vào pom.xl\n\u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.1.0\u003c/version\u003e \u003c/dependency\u003e\rNếu chạy bằng tay, tải file .jar tại https://dev.mysql.com/downloads/connector/j/ và thêm vào classpath của project.","bắt-đầu-nào#Bắt đầu nào!":"Trong các ứng dụng Java, việc lưu trữ và truy xuất dữ liệu thường được thực hiện thông qua cơ sở dữ liệu. JDBC (Java Database Connectivity) là API tiêu chuẩn giúp Java kết nối và giao tiếp với nhiều hệ quản trị cơ sở dữ liệu khác nhau, chẳng hạn như MySQL.\nBài viết này sẽ hướng dẫn bạn từ cơ bản đến thực hành cách kết nối Java với MySQL và thực hiện truy vấn dữ liệu.\nBạn sẽ học được:\nCấu trúc và thành phần của JDBC Cách kết nối Java với MySQL Thực hiện các thao tác cơ bản: SELECT, INSERT Ví dụ lưu thông tin người dùng hoặc lịch sử chat","cấu-trúc-jdbc-gồm-4-thành-phần-chính#Cấu trúc JDBC gồm 4 thành phần chính:":"Driver – Cầu nối giữa Java và hệ quản trị CSDL\nVí dụ: MySQL có driver riêng là mysql-connector-java.jar.\nConnection – Đại diện cho một kết nối tới cơ sở dữ liệu.\nStatement / PreparedStatement – Dùng để gửi các câu lệnh SQL.\nResultSet – Chứa kết quả trả về khi thực hiện câu lệnh SELECT.\nSơ đồ hoạt động:\nflowchart LR\rA[Java Application] --\u003e B[JDBC API]\rB --\u003e C[JDBC Driver]\rC --\u003e D[(MySQL Database)]","kết-luận#Kết luận":"JDBC cho phép Java giao tiếp với MySQL để thực hiện CRUD cơ bản. Nên dùng PreparedStatement, try-with-resources và connection pooling khi ứng dụng lớn. Hiểu JDBC là nền tảng để học Hibernate / JPA.","phần-1--tổng-quan-về-jdbc#Phần 1 — Tổng quan về JDBC":"JDBC là một giao diện lập trình ứng dụng (API) giúp Java có thể:\nKết nối với cơ sở dữ liệu (MySQL, PostgreSQL, SQL Server, v.v.) Gửi và thực thi các lệnh SQL (SELECT, INSERT, UPDATE, DELETE) Nhận kết quả trả về từ cơ sở dữ liệu","phần-2--chuẩn-bị-môi-trường#Phần 2 — Chuẩn bị môi trường":"","phần-3---kết-nối-mysql-bằng-jdbc#Phần 3 - Kết nối MySQL bằng JDBC":"Dưới đây là ví dụ Java cơ bản để kiểm tra kết nối:\nimport java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class ConnectMySQL { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; try { Connection conn = DriverManager.getConnection(url, user, password); System.out.println(\"✅ Kết nối thành công đến MySQL!\"); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }\rGiải thích ngắn:\nDriverManager.getConnection(...) tạo đối tượng Connection. jdbc:mysql://localhost:3306/chat_app là URL kết nối JDBC. Luôn đóng conn sau khi dùng (hoặc dùng try-with-resources).","phần-4--thực-hiện-truy-vấn-sql-cơ-bản#Phần 4 — Thực hiện truy vấn SQL cơ bản":"Thêm dữ liệu (INSERT) import java.sql.*; public class InsertUser { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; String sql = \"INSERT INTO users (username, message) VALUES (?, ?)\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(sql)) { stmt.setString(1, \"Nguyen\"); stmt.setString(2, \"Xin chào mọi người!\"); int rows = stmt.executeUpdate(); if (rows \u003e 0) { System.out.println(\"✅ Thêm dữ liệu thành công!\"); } } catch (SQLException e) { e.printStackTrace(); } } }\rTruy xuất dữ liệu (SELECT) import java.sql.*; public class SelectUser { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; String sql = \"SELECT id, username, message FROM users\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery()) { while (rs.next()) { int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String message = rs.getString(\"message\"); System.out.println(id + \" | \" + username + \" | \" + message); } } catch (SQLException e) { e.printStackTrace(); } } }","phần-5--lưu-ý-khi-làm-việc-với-jdbc#Phần 5 — Lưu ý khi làm việc với JDBC":"Luôn đóng Connection, Statement và ResultSet sau khi sử dụng. Dùng try-with-resources để tự động giải phóng tài nguyên. Sử dụng PreparedStatement thay cho Statement để tránh SQL Injection. Kiểm tra driver MySQL tương thích với JDK hiện tại. Dùng connection pooling (ví dụ HikariCP) cho ứng dụng thực tế để tối ưu hiệu năng.","phần-6--ví-dụ-thực-tế-lưu-lịch-sử-chat#Phần 6 — Ví dụ thực tế: Lưu lịch sử chat":"import java.sql.*; import java.util.Scanner; public class ChatLogger { public static void main(String[] args) { String url = \"jdbc:mysql://localhost:3306/chat_app\"; String user = \"root\"; String password = \"123456\"; Scanner sc = new Scanner(System.in); System.out.print(\"Nhập tên người dùng: \"); String username = sc.nextLine(); System.out.print(\"Nhập tin nhắn: \"); String message = sc.nextLine(); String insertSql = \"INSERT INTO users (username, message) VALUES (?, ?)\"; try (Connection conn = DriverManager.getConnection(url, user, password); PreparedStatement stmt = conn.prepareStatement(insertSql)) { stmt.setString(1, username); stmt.setString(2, message); stmt.executeUpdate(); System.out.println(\"💬 Tin nhắn đã được lưu thành công!\"); } catch (SQLException e) { e.printStackTrace(); } } }","phần-7--cách-chạy#Phần 7 — Cách chạy":"Cách 1 — trong IDE (IntelliJ / Eclipse / NetBeans):\nTạo project, thêm mysql-connector-java.jar vào Libraries / Dependencies. Chạy class như bình thường. Cách 2 — dòng lệnh (Windows):\njavac ConnectMySQL.java java -cp .;mysql-connector-java-8.1.0.jar ConnectMySQL\r(Linux/macOS thay ; bằng :)","tài-liệu-tham-khảo#Tài liệu tham khảo":"JDBC Documentation — Oracle MySQL Connector/J Guide Baeldung — JDBC Basics"},"title":"Kết nối Java với MySQL: Hướng dẫn JDBC cho người mới bắt đầu"},"/blogcuatruc.github.io/blog/bai-7-gioi-thieu-javascript/":{"data":{"":"Nếu HTML là bộ khung của một trang web, CSS là phần trang điểm giúp nó đẹp hơn, thì JavaScript (JS) chính là linh hồn khiến trang web “sống động” — có thể phản hồi người dùng, xử lý dữ liệu, và thay đổi nội dung mà không cần tải lại trang.\nJavaScript là ngôn ngữ lập trình chạy trên trình duyệt, giúp tạo ra trải nghiệm tương tác mà bạn vẫn thấy hằng ngày:\n🔹 Nút bấm bật/tắt menu,\n🔹 Form kiểm tra dữ liệu đầu vào,\n🔹 Ảnh chuyển động, hiệu ứng cuộn,\n🔹 Thông báo, trò chuyện, game trên web, v.v.","-javascript-khác-gì-với-java#⚙️ JavaScript khác gì với Java?":"So sánh Java JavaScript Loại ngôn ngữ Biên dịch Thông dịch Chạy ở đâu Máy ảo JVM Trình duyệt Mục đích Ứng dụng backend, desktop Web frontend Cú pháp Nghiêm ngặt, hướng đối tượng hoàn chỉnh Linh hoạt, hướng đối tượng dựa trên prototype File .java .js","kết-luận#Kết luận":"JavaScript là ngôn ngữ cốt lõi của web hiện đại — thêm tương tác, kiểm tra dữ liệu, hiệu ứng động. Là nền tảng để học React, Vue, Angular, hoặc Node.js.","phần-1--javascript-là-gì#Phần 1 — JavaScript là gì?":"JavaScript là ngôn ngữ lập trình động, thông dịch, và đa nền tảng, được thiết kế để chạy trực tiếp trong trình duyệt.\nViết bằng file .js hoặc nhúng trực tiếp vào HTML. Được trình duyệt (browser) hiểu và thực thi ngay, không cần biên dịch như Java hay C++. Có thể thao tác với nội dung HTML thông qua DOM (Document Object Model).","phần-2--javascript-chạy-trong-trình-duyệt-như-thế-nào#Phần 2 — JavaScript chạy trong trình duyệt như thế nào?":"Khi bạn mở một trang web có JavaScript, trình duyệt sẽ:\nĐọc mã HTML Phân tích và tải file JS Chạy từng dòng mã JavaScript theo thứ tự Cập nhật giao diện (DOM) hoặc phản hồi người dùng Ví dụ, khi bạn bấm nút, JS có thể thay đổi nội dung trang mà không tải lại toàn bộ.\ngraph LR\rA[HTML Trang web] --\u003e B[Trình duyệt]\rB --\u003e C[JavaScript Engine (V8, SpiderMonkey...)]\rC --\u003e D[Thực thi mã JS]\rD --\u003e E[Thay đổi nội dung HTML / DOM]","phần-3--biến-kiểu-dữ-liệu-hàm-toán-tử#Phần 3 — Biến, kiểu dữ liệu, hàm, toán tử":"1️⃣ Biến (Variables)\nDùng để lưu trữ dữ liệu tạm thời. Khai báo bằng let, const hoặc var.\nlet name = \"Truc\"; const age = 21; var city = \"Ho Chi Minh\";\rlet — dùng khi giá trị có thể thay đổi const — dùng khi giá trị cố định var — cú pháp cũ (nên tránh trong code hiện đại) 2️⃣ Kiểu dữ liệu (Data Types)\nKiểu Ví dụ Mô tả Number 10, 3.14 Số học String \"Hello\" Chuỗi ký tự Boolean true, false Đúng / Sai Array [1, 2, 3] Danh sách Object { name: \"An\", age: 20 } Cặp key–value Null / Undefined null, undefined Không có giá trị / chưa gán 3️⃣ Toán tử (Operators)\nlet x = 10; let y = 5; console.log(x + y); // 15 console.log(x * y); // 50 console.log(x \u003e y); // true console.log(x === 10); // true 4️⃣ Hàm (Functions)\nHàm là khối mã có thể tái sử dụng.\nfunction greet(name) { console.log(\"Xin chào, \" + name + \"!\"); } greet(\"Trúc\"); // Xin chào, Trúc! Arrow function (cú pháp hiện đại):\nconst greet = name =\u003e console.log(`Xin chào, ${name}!`);","phần-4--thực-hành-hello-world-đầu-tiên-#Phần 4 — Thực hành “Hello World” đầu tiên 🎉":"1 alert()\n\u003cscript\u003e alert(\"Hello World!\"); \u003c/script\u003e\r2 console.log()\n\u003cscript\u003e console.log(\"Hello World!\"); \u003c/script\u003e\r3 Kết hợp với HTML\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003ch2\u003eXin chào JavaScript!\u003c/h2\u003e \u003cbutton onclick=\"sayHello()\"\u003eNhấn tôi!\u003c/button\u003e \u003cscript\u003e function sayHello() { alert(\"Chào mừng bạn đến với JavaScript!\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e","phần-5--cách-chạy-javascript#Phần 5 — Cách chạy JavaScript":"Nhúng trực tiếp trong HTML: \u003cscript\u003e console.log(\"Hello từ script trong HTML!\"); \u003c/script\u003e\rTách file .js riêng: \u003cscript src=\"main.js\"\u003e\u003c/script\u003e\rmain.js:\nconsole.log(\"Hello từ file riêng!\");\rChạy trong Console của trình duyệt (DevTools → Console): alert(\"Xin chào thế giới!\");","tài-liệu-tham-khảo#Tài liệu tham khảo":"Cisco Academy JavaScript Essential 1 W3Schools — JavaScript Tutorial JavaScript.info — Modern JS Guide ECMAScript Specification (ECMA-262)"},"title":"JavaScript là gì? Cách nó làm cho trang web trở nên sống động"},"/blogcuatruc.github.io/blog/bai-8-dom-va-su-kien/":{"data":{"-cách-1-getelementbyid#🔹 Cách 1: getElementById()":"Truy cập phần tử thông qua id.\nconst title = document.getElementById(\"title\"); title.textContent = \"Xin chào, JavaScript!\";","-cách-2-queryselector#🔹 Cách 2: querySelector()":"Truy cập phần tử bằng CSS selector (rất linh hoạt).\nconst desc = document.querySelector(\".desc\"); desc.style.color = \"blue\";","-cách-3-queryselectorall#🔹 Cách 3: querySelectorAll()":"Trả về tất cả các phần tử khớp selector (NodeList).\nconst items = document.querySelectorAll(\"p\"); items.forEach(item =\u003e item.style.fontWeight = \"bold\");","1-dom-là-gì#1. DOM là gì?":"Khi trình duyệt tải một trang HTML, nó sẽ biến toàn bộ cấu trúc của trang đó thành cây DOM (Document Object Model).\nDOM không chỉ là “nội dung” mà còn là “mô hình dữ liệu” để JavaScript truy cập, sửa đổi, hoặc thêm mới phần tử.\nVí dụ HTML:\n\u003cbody\u003e \u003ch1 id=\"title\"\u003eXin chào!\u003c/h1\u003e \u003cp class=\"desc\"\u003eĐây là đoạn mô tả.\u003c/p\u003e \u003c/body\u003e\rCấu trúc DOM sẽ trông như thế này:\ngraph TD\rDocument --\u003e html\rhtml --\u003e head\rhtml --\u003e body\rbody --\u003e h1[\"h1 id=\\\"title\\\"\"]\rbody --\u003e p[\"p class=\\\"desc\\\"\"]\rDocument\r└─ html\r├─ head\r└─ body\r├─ h1 id=\"title\"\r└─ p class=\"desc\"\rJavaScript có thể đi vào cây DOM để thay đổi bất kì phần tử nào","2-truy-cập-phần-tử-html#2. Truy cập phần tử HTML":"","3-thay-đổi-nội-dung-và-thuộc-tính#3. Thay đổi nội dung và thuộc tính":"JavaScript cho phép thay đổi nội dung, style và class của phần tử:\nconst box = document.getElementById(\"title\"); box.textContent = \"Chào mừng đến với DOM!\"; box.style.backgroundColor = \"lightcoral\"; box.style.padding = \"10px\";\rKết quả: phần tử đổi nội dung và có nền màu đỏ nhạt.","4-sự-kiện-event-trong-javascript#4. Sự kiện (Event) trong JavaScript":"Sự kiện là hành động người dùng thực hiện: nhấp, nhập, rê chuột, cuộn trang…\nMột số sự kiện phổ biến:\nclick — Khi người dùng nhấp chuột mouseover — Khi con trỏ rê qua phần tử input — Khi người dùng nhập dữ liệu change — Khi giá trị đầu vào thay đổi keydown — Khi người dùng nhấn phím","5-ví-dụ-nút-đổi-màu-nền#5. Ví dụ: Nút đổi màu nền":"HTML:\n\u003ch2\u003eThay đổi màu nền\u003c/h2\u003e \u003cbutton id=\"btn\"\u003eĐổi màu\u003c/button\u003e\rJavaScript:\nconst btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", function() { document.body.style.backgroundColor = document.body.style.backgroundColor === \"lightblue\" ? \"white\" : \"lightblue\"; });\rMỗi lần bấm nút, trang sẽ đổi màu nền giữa trắng và xanh nhạt.","6-ví-dụ-nâng-cao-hiển-thị-thời-gian-thực#6. Ví dụ nâng cao: Hiển thị thời gian thực":"HTML:\n\u003cp\u003eGiờ hiện tại: \u003cspan id=\"clock\"\u003e\u003c/span\u003e\u003c/p\u003e\rJavaScript:\nfunction updateClock() { const now = new Date(); const time = now.toLocaleTimeString(); document.getElementById(\"clock\").textContent = time; } setInterval(updateClock, 1000); updateClock(); // gọi ngay để không phải chờ 1s Kết quả: Đồng hồ chạy từng giây ngay trên trang web.","7-cách-gắn-sự-kiện-trong-html-không-khuyến-khích#7. Cách gắn sự kiện trong HTML (không khuyến khích)":"Bạn có thể gắn trực tiếp:\n\u003cbutton onclick=\"alert('Xin chào!')\"\u003eBấm vào đây\u003c/button\u003e\rNhưng tốt hơn là dùng addEventListener() để tách logic JS khỏi HTML.","8-tóm-tắt-kiến-thức#8. Tóm tắt kiến thức":"Khái niệm Mô tả DOM Mô hình cây đại diện cho tài liệu HTML getElementById / querySelector Dùng để truy cập phần tử addEventListener Dùng để lắng nghe sự kiện Event Hành động của người dùng (click, input, …)","bài-8-dom-và-sự-kiện--làm-web-tương-tác#Bài 8. DOM và Sự kiện – Làm web tương tác":"Bài 8. DOM và Sự kiện – Làm web tương tác","kết-luận#Kết luận":"DOM và sự kiện là trái tim của lập trình web bằng JavaScript. Chúng giúp:\nThay đổi giao diện linh hoạt mà không cần tải lại trang. Trang web phản ứng theo từng hành động người dùng. Trong bài tiếp theo, bạn sẽ học cách để JavaScript giao tiếp với server — tải dữ liệu, hiển thị bài viết, hoặc gửi yêu cầu API bằng Fetch API và JSON","mục-tiêu#Mục tiêu":"Hiểu DOM (Document Object Model) là gì và vì sao nó quan trọng. Biết cách truy cập và thay đổi phần tử HTML bằng JavaScript. Làm quen với xử lý sự kiện (Event Handling) như click, input, change. Tự tay làm ví dụ tương tác như đổi màu nền hoặc hiển thị thời gian thực."},"title":"DOM và Event trong JavaScript – Khi trang web biết ‘phản hồi’ người dùng"},"/blogcuatruc.github.io/blog/bai-9-giao-tiep-mang-voi-javascript/":{"data":{"":"","1-giới-thiệu#1. Giới thiệu":"Ngày nay, các ứng dụng web hiện đại không chỉ hiển thị nội dung tĩnh mà còn trao đổi dữ liệu với server để cập nhật thông tin liên tục.\nJavaScript cung cấp công cụ mạnh mẽ để thực hiện việc này – đó là Fetch API.\nFetch API cho phép bạn gửi yêu cầu HTTP (GET, POST, PUT, DELETE, …) và nhận dữ liệu phản hồi từ server, thường ở định dạng JSON.","2-gửi-và-nhận-dữ-liệu-bằng-fetch-api#2. Gửi và nhận dữ liệu bằng Fetch API":"Cú pháp cơ bản:\nfetch(url, { method: \"GET\", // hoặc POST, PUT, DELETE... headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(data) // chỉ dùng khi gửi dữ liệu }) .then(response =\u003e response.json()) .then(data =\u003e console.log(data)) .catch(error =\u003e console.error(\"Lỗi:\", error));\rGiải thích:\nfetch() trả về Promise, cho phép xử lý bất đồng bộ.\nresponse.json() giúp chuyển phản hồi (response) từ server sang đối tượng JSON mà JS có thể sử dụng.\ncatch() bắt lỗi nếu quá trình kết nối thất bại.\nJavaScript có thể chuyển đổi giữa chuỗi và đối tượng JSON bằng:\nconst jsonString = JSON.stringify({ name: \"Truc\", age: 21 }); const obj = JSON.parse(jsonString);","3-ví-dụ-gọi-api-công-khai#3. Ví dụ: Gọi API công khai":"Chúng ta sẽ gọi API https://jsonplaceholder.typicode.com/posts để lấy danh sách bài viết mẫu và hiển thị 10 bài đầu tiên.\nHTML\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eFetch API Demo\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: #fafafa; padding: 20px; } .post { background: white; margin-bottom: 15px; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } h2 { color: #2c3e50; margin:0 0 8px 0; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eDanh sách bài viết\u003c/h1\u003e \u003cdiv id=\"post-list\"\u003e\u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\rJavaScript (file script.js)\nconst postList = document.getElementById(\"post-list\"); fetch(\"https://jsonplaceholder.typicode.com/posts\") .then(response =\u003e response.json()) .then(posts =\u003e { posts.slice(0, 10).forEach(post =\u003e { const div = document.createElement(\"div\"); div.className = \"post\"; div.innerHTML = ` ${post.title} ${post.body}\n`; postList.appendChild(div); }); }) .catch(error =\u003e { postList.innerHTML = `Lỗi tải dữ liệu: ${error}\n`; });","4-ví-dụ-gọi-api-công-khai#4. Ví dụ: Gọi API công khai":"Chúng ta sẽ gọi API https://jsonplaceholder.typicode.com/posts để lấy danh sách bài viết mẫu và hiển thị 10 bài đầu tiên.\nHTML\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"vi\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eFetch API Demo\u003c/title\u003e \u003cstyle\u003e body { font-family: Arial, sans-serif; background: #fafafa; padding: 20px; } .post { background: white; margin-bottom: 15px; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } h2 { color: #2c3e50; margin:0 0 8px 0; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eDanh sách bài viết\u003c/h1\u003e \u003cdiv id=\"post-list\"\u003e\u003c/div\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\rJavaScript (file script.js)\nconst postList = document.getElementById(\"post-list\"); fetch(\"https://jsonplaceholder.typicode.com/posts\") .then(response =\u003e response.json()) .then(posts =\u003e { posts.slice(0, 10).forEach(post =\u003e { const div = document.createElement(\"div\"); div.className = \"post\"; div.innerHTML = ` ${post.title} ${post.body}\n`; postList.appendChild(div); }); }) .catch(error =\u003e { postList.innerHTML = `Lỗi tải dữ liệu: ${error}\n`; });","5-kết-quả-minh-họa#5. Kết quả minh họa":"Khi chạy trang này, trình duyệt sẽ gửi yêu cầu đến API và hiển thị 10 bài viết đầu tiên, ví dụ:\nBài viết 1: sunt aut facere repellat provident occaecati excepturi optio reprehenderit Bài viết 2: qui est esse Bài viết 3: ea molestias quasi exercitationem repellat qui ipsa sit aut … Mỗi bài được hiển thị trong một khung .post riêng.","6-tổng-kết#6. Tổng kết":"Khái niệm Ý nghĩa Fetch API Gửi/nhận HTTP từ JavaScript Promise Xử lý bất đồng bộ (then/catch) JSON Định dạng dữ liệu phổ biến giữa client và server Fetch API là cầu nối giữa frontend và backend, giúp ứng dụng web động và phản hồi nhanh với người dùng.","7-bài-tập-mở-rộng#7. Bài tập mở rộng":"Thêm tính năng hiển thị chi tiết bài viết khi click vào tiêu đề. Viết form để gửi dữ liệu (POST) lên API (ví dụ jsonplaceholder cho phép thử POST). Viết lại đoạn fetch bằng async/await để mã ngắn gọn hơn. Thêm xử lý loading/error UI (spinner, thông báo lỗi)."},"title":"Kết nối server bằng Fetch API – Cách JavaScript trò chuyện với backend"},"/blogcuatruc.github.io/posts/":{"data":{"":"🎓 Profile Cá Nhân: Nguyễn Hồ Ngọc Trúc","-profile-cá-nhân-nguyễn-hồ-ngọc-trúc#🎓 Profile Cá Nhân: Nguyễn Hồ Ngọc Trúc":"","i-giới-thiệu-chung#I. Giới Thiệu Chung":"Xin chào, tôi là Nguyễn Hồ Ngọc Trúc, sinh viên khoa Công nghệ thông tin chuyên ngành Công nghệ phần mềm.\nTrong thế giới lập trình, tôi tự nhận là một người có xu hướng “học tập tối giản”. Không phải vì thiếu đam mê, mà vì tôi luôn tìm kiếm con đường ngắn nhất, cô đọng nhất để nắm bắt kiến thức phức tạp.\nTôi tin rằng, khi bạn là người lười, bạn sẽ buộc phải tìm ra cách hiểu bài dễ nhất, nhớ lâu nhất, và dễ áp dụng nhất để không phải làm lại.","ii-mục-tiêu-và-triết-lý-chia-sẻ#II. Mục Tiêu và Triết Lý Chia Sẻ":"Blog cá nhân này được xây dựng dựa trên triết lý “Học tập tối giản cho người lười” đó, nhằm đạt được các mục tiêu sau:\nCô đọng tối đa: Loại bỏ lý thuyết lan man, chỉ giữ lại những khái niệm cốt lõi, dễ hình dung. Dễ áp dụng: Tập trung vào các ví dụ thực tế, có thể áp dụng ngay vào dự án. Hệ thống hóa: Sắp xếp kiến thức theo một lộ trình logic, dễ tiếp cận ngay cả với người mới bắt đầu.","iii-chuyên-môn-và-tài-liệu-cốt-lõi#III. Chuyên Môn và Tài Liệu Cốt Lõi":"Nội dung chính của blog này là đồ án môn học của tôi, tập trung vào hai lĩnh vực và tài liệu sau:\nLĩnh vực Trọng tâm Java (Backend) Nghiên cứu về kiến trúc Hướng Đối Tượng (OOP), Lập trình Mạng (Socket) và các giải pháp server-side. JavaScript (Frontend/Full-stack) Nắm vững tương tác DOM, Lập trình Bất Đồng Bộ và các khái niệm lập trình web động. Toàn bộ kiến thức được tổng hợp, phân tích và diễn giải lại từ hai nguồn tài liệu chính thức:\nCisco Networking Academy: JavaScript Essentials 1 Cisco Networking Academy: JavaScript Essentials 2 Hy vọng những chia sẻ “cô đọng cho người lười” này sẽ giúp bạn tiếp thu kiến thức lập trình một cách nhanh chóng và hiệu quả nhất!","iv-thông-tin-liên-hệ#IV. Thông Tin Liên Hệ":"Email: ngoctrucnguyen3012@gmail.com GitHub Repositories (Đồ án): [Link đến GitHub Repositories của Đồ án] Tham khảo Profile Cá nhân: [Link đến Wixsite/Portfolio của bạn]"},"title":"Profile Cá Nhân"}}